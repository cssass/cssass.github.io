<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Drive2Far</title>
  
  <subtitle>开过头先生的主页</subtitle>
  <link href="https://www.cssass.com/atom.xml" rel="self"/>
  
  <link href="https://www.cssass.com/"/>
  <updated>2023-06-30T08:15:23.954Z</updated>
  <id>https://www.cssass.com/</id>
  
  <author>
    <name>Neo One</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>真随机和伪随机</title>
    <link href="https://www.cssass.com/2023/03/31/%E7%9C%9F%E9%9A%8F%E6%9C%BA%E5%92%8C%E4%BC%AA%E9%9A%8F%E6%9C%BA/"/>
    <id>https://www.cssass.com/2023/03/31/%E7%9C%9F%E9%9A%8F%E6%9C%BA%E5%92%8C%E4%BC%AA%E9%9A%8F%E6%9C%BA/</id>
    <published>2023-03-31T07:59:47.000Z</published>
    <updated>2023-06-30T08:15:23.954Z</updated>
    
    <content type="html"><![CDATA[<p>你是一个凡人，上帝用意志创造了一副牌，你无法偷看无法修改，对于抽牌的你来说，这是一个真随机；<br>你是一个程序员，计算机创造了一个random函数，你无法偷看无法修改，对于使用random的你来说，这是个真随机；<br>你是一个抽奖用户，程序员用random函数写了一个抽奖程序，你无法偷看无法修改，但是你死活不信抽奖程序是真随机的，因为你觉得程序员的抽奖算法可能已经预设好了中奖概率，也就是所谓的伪随机。<br>如此说来，程序员也可以不信任计算机，random函数是计算机事先设计好的随机算法，从这个角度看，难道就没有伪随机的可能吗。<br>以此类推，上帝面前的这幅牌，也是通过他的意志创造出来的，你去抽牌这事的不也可能是伪随机吗？<br>私认为，程序员质疑计算机，‘凡人’质疑‘上帝’，简直没事找事。<br>但是用户质疑程序员，这似乎情有可原：因为程序员到底是用了一套动了手脚的程序（伪随机），还是使用了计算机的random函数（真随机），这种事真不好说啊，作为客户就更加无法辨别了!<br>怎么办呢？<br>对于不相信程序员，但还算相信计算机的用户，我们可以引入一个不可操控的‘种子’，比方说某时某地的气温，通过用户可验证的随机算法，生成出一个随机数出来，排除掉程序员制造伪随机的可能性，这样就能令其信服了。<br>但对于那些连‘上帝’也质疑的用户，那就别多费口舌了。<br>最后，我们想想看伪随机这种东西有没有用处呢？<br>还真有这种需求，真随机这东西老被用户质疑是伪随机，并非都怪用户找茬，他还真有”犯罪证据”被抓着。比方说一个抽卡游戏，抽中SSR的概率官方说是5%，结果用户抽了20次没抽到，30次还没抽到，这正常吗？正常啊！但是客户不觉得，认为这就是程序员制造“伪随机”的证据。所以呢，有时候程序员反而需要写一个伪随机算法，让用户抽20次必中1次，让用户感觉上觉得这个游戏是“真”随机。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你是一个凡人，上帝用意志创造了一副牌，你无法偷看无法修改，对于抽牌的你来说，这是一个真随机；&lt;br&gt;你是一个程序员，计算机创造了一个random函数，你无法偷看无法修改，对于使用random的你来说，这是个真随机；&lt;br&gt;你是一个抽奖用户，程序员用random函数写了一个抽</summary>
      
    
    
    
    <category term="essay" scheme="https://www.cssass.com/categories/essay/"/>
    
    
    <category term="Math" scheme="https://www.cssass.com/tags/Math/"/>
    
    <category term="概率" scheme="https://www.cssass.com/tags/%E6%A6%82%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>四.如何计算房贷——复利/折现/年金公式</title>
    <link href="https://www.cssass.com/2018/10/14/%E5%9B%9B-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%88%BF%E8%B4%B7%E2%80%94%E2%80%94%E5%A4%8D%E5%88%A9-%E6%8A%98%E7%8E%B0-%E5%B9%B4%E9%87%91%E5%85%AC%E5%BC%8F/"/>
    <id>https://www.cssass.com/2018/10/14/%E5%9B%9B-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%88%BF%E8%B4%B7%E2%80%94%E2%80%94%E5%A4%8D%E5%88%A9-%E6%8A%98%E7%8E%B0-%E5%B9%B4%E9%87%91%E5%85%AC%E5%BC%8F/</id>
    <published>2018-10-14T05:50:56.000Z</published>
    <updated>2023-07-03T08:17:44.107Z</updated>
    
    <content type="html"><![CDATA[<p>有人问：等额本金 和 等额本息 这两种还贷方式哪种更划算？</p><p>王顾左右而言他：如果你是一家银行，有一笔半年期的总额60万的贷款放在面前，为了计算方便假设贷款年利率为6%（一般房贷利率不会这么高），你觉得选择等额本金或者等额本息哪个的收益更高呢？二选一，不能拒贷！</p><p>这个问题一下就回到了本系列的第二篇的内容：《如何评估收益——折现公式》，只需计算两种还款现金流的现值总和，对比一下结果就知道了。</p><p>计算之前，还是先简单介绍一下这两种还款方式：</p><p>一：等额本金，每个月除了先把平摊的本金还了，还要加上这个月产生的所有利息一并全还，由于是利息全还，在下个月将不会产生利息的利息(所以是单利，计算简单)；</p><p>二：等额本息，这种方式先要计算得出贷款期内本金和利息之和(还款总额)，再平摊到每个月进行还款，而这个还款总额是一个利滚利(月复利)的结果，当然因为每月都在还款，并非所有利息及本金都会参与复利。</p><p>下面依照6%年利率列出两种方式的还款流水(可以使用网上各种贷款计算器算出，后文里我也会推导给出详细的计算方法)：</p><p>103000+102500+102000+101500+101000+100500 &#x3D; 610500</p><p>101757.27 *6 &#x3D; 610543</p><p>上面两张图中，各自的下层为每月所还本金，上层为所还利息。它们的还款总额分别为：等额本金610500元、等额本息610543元，显然等额本息比等额本金的应还金额要多，本金一致，多出的是利息。如果贷款周期拉长，两者的利息差还是相当可观的，那么是不是就说明对银行来说等额本息更有利呢？显然不是，我们还是需要通过现值来进行比较。</p><p>依照折现公式（折现率就取6%&#x2F;12）：</p><p>折现公式(单期)</p><p>则等额本金的现值总和：</p><p>&#x3D; 600000</p><p>依照年金公式：（为什么等额本息求现值可以使用年金公式，请看本系列第三篇《三.如何计算养老金——年金现值公式》）</p><p>年金现值公式</p><p>则等额本息的现值总和：101757.2733*(1-1&#x2F;(1+0.06&#x2F;12)^6)&#x2F;(0.06&#x2F;12)</p><p>&#x3D;600000</p><p>两者的计算结果完全相等，所以可以很明确的说：等额本金与等额本息对银行来说，其投资收益都是一样的，就相当于一笔半年期（期满才取款）的月复利0.5%（0.06&#x2F;12）的存款。</p><p>虽然我们已经知道两种放贷方式对银行的收益来说都是一样的，都是月复利0.5%，但是你可能更关心它的年化收益，毕竟这是大多数投资核算最通用的指标。我们在第一篇讲《如何计算年化收益——复利公式》的时候就说过，采用复利的情况下，年化收益率的计算并不是简单的 0.5% * 12 &#x3D; 6%。而是需要使用复利公式计算：</p><p>年收益率k &#x3D; (终值F - 现值P)&#x2F;现值P &#x3D; (F&#x2F;P - 1) &#x3D; (1+i)^n - 1 &#x3D; (1+0.005)^12 - 1 &#x3D; 6.17%</p><p>所以，虽然银行房贷标明的贷款名义利率为6%，但是它的实际年化利率却是6.17%，会高于贷款的名义利率，原因就在于它是按照每月算利息还款的，而这个月利率是直接拿名义贷款利率除以12个月得出的。</p><p>如果你还有兴趣再了解一下两种贷款具体是怎么计息还款的，那下面就和我一起来做个房贷计算器吧。</p><p>我们先定义几个变量：credit:贷款总额，rate:贷款利率(年), period:贷款期限(月)</p><p>一：对于等额本金</p><ol><li><p>应还本金为：credit&#x2F;period 。每月应还本金 &#x3D; 贷款总额 &#x2F; 贷款期限。假设贷金款60万，贷款期限6个月，那么每个月的应还本金固定就是：60万&#x2F;6月 &#x3D; 10万&#x2F;月</p></li><li><p>应还利息为：credit * rate&#x2F;12。应还利息 &#x3D; 未还贷款余额 乘以 当月的利率。同样半年期60万的贷款，为了便于计算假设年利息为6%，第一个月的还款利息就是：60万*0.06&#x2F;12 &#x3D; 3000元（由于6%是年利率，我们需要除以12换成了月利率）。</p></li></ol><p>在第一个月还款（10万 + 0.3万）之后，由于是等额本金第二个月还款本金依然是10万，但是第二个月的利息呢？</p><p>首先，在第一个月还款之前，我们本金是60万整，第一个月产生利息0.3万，总金额变成60.3万，然后经过还款，总金额变成60.3 - 10.3 &#x3D; 50万，可以看出这种方式是利息全还(不发生利滚利，产生利息不计入下月利息的计算)，本金还了6分之1，依此第二个月计算利息的金额就是50万，计算一下，50*0.06&#x2F;12 &#x3D; 2500元 就是第二个月的应还利息。</p><p>综上每月应还利息为： (credit - credit&#x2F;period * i ) * (rate&#x2F;12) 。其中i为第几期。</p><p>合计一下利息之和：</p><p>1.05万</p><p>如果直接算总利息，也可以直接套用以下公式计算：</p><p>应还总利息</p><p>等额本金的应还本金、应还利息就此计算完毕。</p><p>二：等额本息，前面讲过，这种方式要先知道贷款期内本金和利息之和(还款总额)，再平摊到每个月进行还款。而这个还款总额是一个利滚利(复利)的结果：本月利息计入本金，再减去还款金额，接着计算下一个月还款额。</p><p>这里再插一句关于复利，不要提到复利就想到像高利贷一样暴利，其实这是一种非常常见的计息方式。比如余额宝，它就是一个日复利的过程，只是日复利的利息很低，低到每天利滚利滚了365天之后，折算成一年的总利率也才3%不到。所以在复利利率不高的情况下，利息虽然比单利要多，也多不到哪去，你只要想想你每天的余额宝收益就能理解，比如今日余额宝的万份收益0.7374举例(万份收益就表明了余额宝当前的日复利率&#x3D;0.00007374), 如果今天有100块的收益(显然本金已经很高了)，那这100块第二天也仅仅能给你多产生7.4厘的利息而已。</p><p>回到等额本息计算，我们知道，等额本息还款实际上是一笔年金还款，我们依照年金公式（年金公式的推导可以查看前一篇）。</p><p>每月还款A(包含本金和利息) 就等于 总现值(即贷款总额credit) 除以 年金因子(括号内式子)。有了每月还款金额A之后，大功已然告成。</p><p>接下来想要知道每月还款A里面本金占多少？依据折现公式计算即可：</p><p>折现公式</p><p>折现系数</p><p>每月应还本金（就是当月还款额的现值P1）等于，每月还款额A（就是当月现金流F1） 乘以 当月的折现系数。而每月应还利息，直接取终值与现值之差： F 1 - P1</p><p>以上，等额本息的流水也计算完毕。</p><p>按照以上思路，我来编写一下程序，可视化房贷计算器（具体不多赘述了，想看源码可以点开链接，按下Ctrl+U（Windows电脑）或 option+Command+U键（Mac电脑）进行查看，找到第60行到80行）。</p><p>以下是可视化结果截图。</p><p>贷款120万，利率5%，25年<br>略作讲解：</p><p>1.图1与图2来看等额本金前期还款压力较大；</p><p>2.图3表明了本金还款的分布，当然本金最后还的总额还是一样的；</p><p>3.图4的凸出的部分就是等额本息比等额本金要多还的利息；</p><p>4.图4可以推断，等额本息受利率波动影响会大一些。</p><p>结语：房子是用来住的，不是用来炒的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有人问：等额本金 和 等额本息 这两种还贷方式哪种更划算？&lt;/p&gt;
&lt;p&gt;王顾左右而言他：如果你是一家银行，有一笔半年期的总额60万的贷款放在面前，为了计算方便假设贷款年利率为6%（一般房贷利率不会这么高），你觉得选择等额本金或者等额本息哪个的收益更高呢？二选一，不能拒贷！</summary>
      
    
    
    
    <category term="economic" scheme="https://www.cssass.com/categories/economic/"/>
    
    
    <category term="复利" scheme="https://www.cssass.com/tags/%E5%A4%8D%E5%88%A9/"/>
    
    <category term="年金" scheme="https://www.cssass.com/tags/%E5%B9%B4%E9%87%91/"/>
    
    <category term="房贷" scheme="https://www.cssass.com/tags/%E6%88%BF%E8%B4%B7/"/>
    
  </entry>
  
  <entry>
    <title>三.如何计算养老金——年金现值公式</title>
    <link href="https://www.cssass.com/2018/09/20/%E4%B8%89-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%85%BB%E8%80%81%E9%87%91%E2%80%94%E2%80%94%E5%B9%B4%E9%87%91%E7%8E%B0%E5%80%BC%E5%85%AC%E5%BC%8F/"/>
    <id>https://www.cssass.com/2018/09/20/%E4%B8%89-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%85%BB%E8%80%81%E9%87%91%E2%80%94%E2%80%94%E5%B9%B4%E9%87%91%E7%8E%B0%E5%80%BC%E5%85%AC%E5%BC%8F/</id>
    <published>2018-09-20T05:42:11.000Z</published>
    <updated>2023-07-17T08:52:23.914Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇《如何评估收益——折现公式》中，我们使用了净现值来评估一个项目的收益，今天来评估一个养老金项目：</p><p>有一个养老金项目，需要在60岁时缴满27万元，那在之后的每一个月里就可以拿到4000元的养老金。<br>为了便于计算，我们先改一下项目：缴27万，之后每年返回4.8万元。我们拿10年期、每年折现率10%来核算：</p><p>4.8&#x2F;(1+0.1)^10+4.8&#x2F;(1+0.1)^9+4.8&#x2F;(1+0.1)^8+4.8&#x2F;(1+0.1)^7+4.8&#x2F;(1+0.1)^6+4.8&#x2F;(1+0.1)^5+4.8&#x2F;(1+0.1)^4+4.8&#x2F;(1+0.1)^3+4.8&#x2F;(1+0.1)^2+4.8&#x2F;(1+0.1)^1 &#x3D; 29.5（也可直接使用excel公式进行计算：&#x3D;PV(0.1,10,-4.8)）</p><p>得到的结果减去本金就是净现值： 29.5-27 &#x3D; 2.5万元， 说明这个养老金项目比10%复利的10年期项目收益要更高。</p><p>上面的计算式，有一个特点：每一项的分子都是一样的——4.8。所以计算过程可以简化为: 4.8((1-(1+0.1)^-10)&#x2F;0.1) &#x3D; 29.5</p><p>相应的，折现求和公式也可以简化成：</p><img src="/2018/09/20/%E4%B8%89-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%85%BB%E8%80%81%E9%87%91%E2%80%94%E2%80%94%E5%B9%B4%E9%87%91%E7%8E%B0%E5%80%BC%E5%85%AC%E5%BC%8F/1.webp" class=""><p>这种“每隔一定相等的时期，收到或付出的相同数量款项”，有一个专有名词叫做“年金”。</p><p>而以上的公式则被称为年金现值公式。括号内的值称为年金因子。</p><p>有了年金现值公式，计算各个时长的现值就非常的方便了。</p><p>比如算10年，我们精确到月计算，即总计120期，每期返回0.4万元，对应的月利率为0.1&#x2F;12&#x3D;0.00833, 计算结果如下：</p><p>0.4((1-(1+0.0083)^-120)&#x2F;0.0083) &#x3D; 30.32 万。 净现值为 30.32 - 27 &#x3D; 3.32万</p><p>算20年期(240期)，则为：</p><p>0.4((1-(1+0.0083)^-240)&#x2F;0.0083) &#x3D; 41.56万。 净现值为 41.56 - 27 &#x3D; 14.56万</p><p>这个净现值已经非常高了，可以说远远超过了10%的年收益率。假如期数持续增加，乃至无限大，其结果会怎样呢？</p><p>当n无穷大，年金因子将趋向于 1&#x2F;i , 年金现值将趋向于：</p><img src="/2018/09/20/%E4%B8%89-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%85%BB%E8%80%81%E9%87%91%E2%80%94%E2%80%94%E5%B9%B4%E9%87%91%E7%8E%B0%E5%80%BC%E5%85%AC%E5%BC%8F/2.webp" class=""><p>按10%的贴现率，养老金的现值极限为48.2万，已经远大于投资金额27万</p><p>这种无限期的年金我们称为永续年金。</p><p>以上公式，如果把P看做本金，A看作利息，i看作利率，则可以构成一个初级等式： 利息 &#x3D; 本金 * 利率。</p><p>假定养老金无限期，我们计算一下它的“利率”：i &#x3D; A &#x2F; P &#x3D; 1.48%月利 。按照复利折算成年实际收益率差不多是19.3%，也就是说如果养老金能一直拿下去，那它的年收益率就是19.3%。</p><p>当然以上的无限期只是一个假设的情况，但在房产市场，却真实存在一种永续年金，叫做房租。一套200万买的房子拿来出租，每月租金5000，我们算一下它的“利率”：i &#x3D; A &#x2F; P &#x3D; 5000&#x2F;2000000 &#x3D;1&#x2F;400 &#x3D; 0.25% 。这个“利率”，现在也有一个专用名词，叫做“租售比”。</p><p>按照租售比的含义讲，1&#x2F;400的租售比，就是说要收大约33年（400个月）的房租后，房东能收回全部房款了。这里要说明一下，不同于养老金，养老金投入的本金收回是合算在每期的“利息”里的，相当于“本息”。而房租却是“纯利息”，你的房子则永远还是你的。</p><p>一般认为房子的租售比的合理范围是在1&#x2F;300到1&#x2F;200之间，就是说在300个月到200个月之间能收回买房款比较合理，这个租售比折算成“年利率”是4%—6%。如果小于1&#x2F;300（年利率低于4%）, 也就是说要300个月（25年）以上才能拿回购房款的，一般就认为房子存在泡沫。这里插一句，租售比通常是用来评估房产泡沫（房价高低）的，而不是评估房租高低的。一些人说中国租售比这么低，房租还可以涨的说法，根本就是本末倒置。</p><p>结语：愿全天下父母长命百岁，好人一生平安。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇《如何评估收益——折现公式》中，我们使用了净现值来评估一个项目的收益，今天来评估一个养老金项目：&lt;/p&gt;
&lt;p&gt;有一个养老金项目，需要在60岁时缴满27万元，那在之后的每一个月里就可以拿到4000元的养老金。&lt;br&gt;为了便于计算，我们先改一下项目：缴27万，之后每年返</summary>
      
    
    
    
    <category term="economic" scheme="https://www.cssass.com/categories/economic/"/>
    
    
    <category term="复利" scheme="https://www.cssass.com/tags/%E5%A4%8D%E5%88%A9/"/>
    
    <category term="年金" scheme="https://www.cssass.com/tags/%E5%B9%B4%E9%87%91/"/>
    
  </entry>
  
  <entry>
    <title>二.如何评估收益——折现公式</title>
    <link href="https://www.cssass.com/2018/09/16/%E4%BA%8C-%E5%A6%82%E4%BD%95%E8%AF%84%E4%BC%B0%E6%94%B6%E7%9B%8A%E2%80%94%E2%80%94%E6%8A%98%E7%8E%B0%E5%85%AC%E5%BC%8F/"/>
    <id>https://www.cssass.com/2018/09/16/%E4%BA%8C-%E5%A6%82%E4%BD%95%E8%AF%84%E4%BC%B0%E6%94%B6%E7%9B%8A%E2%80%94%E2%80%94%E6%8A%98%E7%8E%B0%E5%85%AC%E5%BC%8F/</id>
    <published>2018-09-16T12:47:05.000Z</published>
    <updated>2023-07-03T08:17:55.390Z</updated>
    
    <content type="html"><![CDATA[<p>假如你手上有100万现金，有这样两个项目摆在你面前让你选，你会选哪个？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">项目1：投资100万，第一年返回60万，第二年返回50万，第三年返回10万；</span><br><span class="line">项目2：投资100万，第一年返回40万，第二年返回40万，第三年返回40万；</span><br></pre></td></tr></table></figure><p>两个项目三年之后的收益都是20万，但是聪明的你肯定会选择第一个项目，为什么，因为第一年60万回来之后，相比40万，你就多20万的资金去投下一个项目，拿到更多的收益。</p><p>这时候来了第三个项目：投资100万，周期三年，每年10%的复利，那你会选哪个项目呢？注意这里是复利，前面说过利息计算有两种方式：一种是单利法，只算本金的利息，不考虑利息产生的利息；第二种是就是复利法，利息算入本金一起算下一期的利息。</p><p>我们发现这和前两个项目的表述不一样，前面是列出了每年的现金流，而这个项目，前两年的现金流我们可以知道是0，但是第三年的终值是多少，我们需要通过利息来计算才能得知（这是一个复利过程，见前一篇《如何计算年化收益——复利公式》)：</p><img src="/2018/09/16/%E4%BA%8C-%E5%A6%82%E4%BD%95%E8%AF%84%E4%BC%B0%E6%94%B6%E7%9B%8A%E2%80%94%E2%80%94%E6%8A%98%E7%8E%B0%E5%85%AC%E5%BC%8F/1.webp" class=""><p>其中P是现值&#x3D;100万，i是年利率&#x3D;0.1，n是周期&#x3D;3年。终值 F &#x3D; 100*(1+0.1)^3 &#x3D; 133.1万。</p><p>现在我们把三个项目放在一起对比：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">项目1：投资100万，第一年返回60万，第二年返回50万，第三年返回10万；</span><br><span class="line">项目2：投资100万，第一年返回40万，第二年返回40万，第三年返回40万；</span><br><span class="line">项目3：投资100万，第一年返回0 ，第二年返回0，第三年返回133.1万；</span><br></pre></td></tr></table></figure><p>你还能一眼看出哪个项目的收益更划算吗？</p><p>对于项目3，我们一开始就知道了它的年化收益率是10%，而对于项目1和2，由于现金流动，我们很难去量化其收益率。那么，在只知道现金流的情况下，该如何去评估其收益呢？有没有其他的量化指标？有！</p><p>再看一下项目3：现值100万，每年利息10%，3年之后的终值是133.1万。而反过来讲就是：133.1万的终值，按10%的年利息，3年前的现值就是100万。</p><p>套用这个讲法，我们看一下第一个项目：10万的终值，按10%的利息，3年前的现值是多少？50万的终值，按10%的年利息，2年前的现值是多少？60万的终值，按10%的利息，1年前的现值是多少？ 这三个现值加起来是多少？假如三年每年收益折算成现值加起来，比100万还多，是不是就表示第一个项目比第三个项目(年利10%)更赚钱呢。</p><p>我们把复利公式也倒过来：P &#x3D; F &#x2F; (1+i)^n 。</p><img src="/2018/09/16/%E4%BA%8C-%E5%A6%82%E4%BD%95%E8%AF%84%E4%BC%B0%E6%94%B6%E7%9B%8A%E2%80%94%E2%80%94%E6%8A%98%E7%8E%B0%E5%85%AC%E5%BC%8F/2.webp" class=""><p>这个公式叫做：折现公式，而利率i在这里叫做贴现率。</p><p>套用折现公式，我们根据前两个项目现金流算一下各自的现值之和。</p><p>项目1：10&#x2F;(1+0.1)^3 + 50&#x2F;(1+0.1)^2 + 60&#x2F;(1+0.1)^1 &#x3D; 7.513 + 41.322 + 54.545 &#x3D; 103.38</p><p>项目2：40&#x2F;(1+0.1)^3 + 40&#x2F;(1+0.1)^2 + 40&#x2F;(1+0.1)^1 &#x3D; 30.053 + 33.058 + 36.363 &#x3D; 99.47</p><p>项目3：133.1&#x2F;(1+0.1)^3 + 0 + 0 &#x3D; 100 （本来就是复利公式的逆向，我们早就知道结果是100）</p><p>可以量化地看出：</p><ol><li><p>通过与项目3对比，项目1比10%的年复利还要赚钱，并且净现值差3.38万元；</p></li><li><p>通过与项目3对比，项目2比10%的年复利要少赚钱，并且净现值差-0.53万元。</p></li></ol><p>以上就是通过折现公式根据终值(或现金流)算现值，将计算得到现值比较一下就能看出哪个项目更赚钱了。</p><p>结语：好了，公式都准备好了，就缺本金和项目了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假如你手上有100万现金，有这样两个项目摆在你面前让你选，你会选哪个？&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span</summary>
      
    
    
    
    <category term="economic" scheme="https://www.cssass.com/categories/economic/"/>
    
    
    <category term="复利" scheme="https://www.cssass.com/tags/%E5%A4%8D%E5%88%A9/"/>
    
    <category term="折现" scheme="https://www.cssass.com/tags/%E6%8A%98%E7%8E%B0/"/>
    
    <category term="净现值" scheme="https://www.cssass.com/tags/%E5%87%80%E7%8E%B0%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>一.如何计算年化收益——复利公式</title>
    <link href="https://www.cssass.com/2018/09/15/%E4%B8%80-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%B9%B4%E5%8C%96%E6%94%B6%E7%9B%8A%E2%80%94%E2%80%94%E5%A4%8D%E5%88%A9%E5%85%AC%E5%BC%8F/"/>
    <id>https://www.cssass.com/2018/09/15/%E4%B8%80-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%B9%B4%E5%8C%96%E6%94%B6%E7%9B%8A%E2%80%94%E2%80%94%E5%A4%8D%E5%88%A9%E5%85%AC%E5%BC%8F/</id>
    <published>2018-09-15T08:34:59.000Z</published>
    <updated>2023-06-30T12:52:32.505Z</updated>
    
    <content type="html"><![CDATA[<p>年化收益率的概念随着余额宝的热潮已经非常普及了。当余额宝年化收益率是5%时，就表示100万本金一年能赚5万块，这是一个非常直观的投钱指标。那为什么叫年化收益率而不叫年收益率呢？因为真实收益率本身是在波动的，你今天的收益率，明天的收益率，今年的收益率，明年的收益率都是在波动而且有一部分是不确定的。所以才有这种年化收益率的概念，它其实是一个根据当前已知收益值通过计算后给出的预估的值。</p><p>如下图显示，2018&#x2F;09&#x2F;16日某货币基金的7日年化为2.9030%，它是根据过去7天的收益情况计算得出的值。</p><img src="/2018/09/15/%E4%B8%80-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%B9%B4%E5%8C%96%E6%94%B6%E7%9B%8A%E2%80%94%E2%80%94%E5%A4%8D%E5%88%A9%E5%85%AC%E5%BC%8F/1.webp" class=""><p>从上图中，我们还看到另一个指标值：万份收益，相比年化收益率，虽然它也是一个波动的值，但却是一个已知确定的值。7日年化收益率就是通过它去预估计算的。图中显示的万份收益是前一天的值，它是一个已确定的值，反映的是前一日的收益率，即昨天每一万元(一份值一元)赚到了0.7374元收益，日收益率即为：0.007374%。</p><p>一些摘取2018&#x2F;9&#x2F;9——2018&#x2F;9&#x2F;15这7日的万份收益数据，我们看一下七日年化的计算过程：</p><img src="/2018/09/15/%E4%B8%80-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%B9%B4%E5%8C%96%E6%94%B6%E7%9B%8A%E2%80%94%E2%80%94%E5%A4%8D%E5%88%A9%E5%85%AC%E5%BC%8F/2.webp" class=""><p>[0.7374, 0.7374, 1.0763, 0.7400, 0.7322, 0,7392, 0.7261]。<br>使用银行利息算法，一年的年利率计算只需7天总收益除7天再乘以365天即可：(0.7374 + 0.7374 + 1.0763 + 0.7400 + 0.7322 +  0.7392 + 0.7261) &#x2F; 7 * 365 &#x2F; 10000 &#x3D; 2.8619%。</p><img src="/2018/09/15/%E4%B8%80-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%B9%B4%E5%8C%96%E6%94%B6%E7%9B%8A%E2%80%94%E2%80%94%E5%A4%8D%E5%88%A9%E5%85%AC%E5%BC%8F/3.webp" class=""><p>&#x3D;0.0286191<br>但是，通过对比余额宝显示的2.9030%，我们的计算结果偏低了。</p><p>原因是余额宝采用了日复利计息方式，而不是银行定存的单利法计息，复利也就是通俗所说的利滚利，利息计算有两种方式，一种是单利法，只算本金的利息，不考虑利息产生的利息，第二种是就是复利法，利息算入本金一起算下一期的利息。</p><p>为了方便讲解，我们先看下面的问题：</p><p>有这样一个项目，100万的资金，投资三年，每年有10%的复利，到第三年期满能拿到多少钱？</p><p>按照10%利息，100万第一年将增值为：100万 + 100万 * 0.1 &#x3D; 110万，到第二年增值为：110万 + 110万 * 0.1 &#x3D; 121万，等到第三年拿到回报时为：121万 + 121万*0.1 &#x3D; 133.1万。</p><p>整理成公式就是：F &#x3D; P * (1+i)^n 。</p><img src="/2018/09/15/%E4%B8%80-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%B9%B4%E5%8C%96%E6%94%B6%E7%9B%8A%E2%80%94%E2%80%94%E5%A4%8D%E5%88%A9%E5%85%AC%E5%BC%8F/4.webp" class=""><p>其中P是现值&#x3D;100万，i是年利率&#x3D;0.1，n是周期&#x3D;3年。重新使用公式计算，终值 F &#x3D; <a href="https://www.wolframalpha.com/input/?i=100*(1+0.1)%5E3" title="" target="">100*(1+0.1)^3 &#x3D; 133.1万</a>。</p><p>以上利用复利法根据现值求终值的过程，叫做复利过程，而这个公式就是复利公式。</p><p>有了复利公式，我们来算一下余额宝的10000元，在0.000078408的日复利下 (7日平均收益率 &#x3D; (0.7374 + 0.7374 + 1.0763 + 0.7400 + 0.7322 +  0.7392 + 0.7261)  &#x2F; 7 &#x2F; 10000 )，365天之后能拿到多少钱。 F &#x3D; <a href="https://www.wolframalpha.com/input?i=10000+*+(1+++0.000078408+)%5E365" title="" target="">10000 * (1 + 0.000078408 )^365 &#x3D; 10290.3</a> 。</p><p>那么年化利率就好算了：(10290.3 - 10000)&#x2F;10000 &#x3D; 2.903% ，与余额宝上面的显示一致，因为这个结果是根据最近7日算出来的，所以叫做7日年化收益率。</p><p>余额宝的年化收益率是平台帮你算好的，那么其他项目我们如何自己去算年化收益率呢？</p><p>我们看一下这个题：周立波事件中“某某”，于2013年以公司名义斥资930万美元买入一套豪宅，与其说是一栋独立屋，不如说是一座城堡。早在1995年时，将这套房卖给某某的业主从更早一个业主手中以155万美元买入。那么这笔交易原业主在1995年至2013年这18年间的年化收益率是多少呢？</p><img src="/2018/09/15/%E4%B8%80-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%B9%B4%E5%8C%96%E6%94%B6%E7%9B%8A%E2%80%94%E2%80%94%E5%A4%8D%E5%88%A9%E5%85%AC%E5%BC%8F/5.webp" class=""><p>还是使用原来的复利公式：F &#x3D; P * (1+i)^n， 已知终值F，现值P，求利率i， 转换一下公式：i &#x3D; (F&#x2F;P)^(1&#x2F;n) - 1。</p><p>带入公式：i &#x3D; <a href="https://www.wolframalpha.com/input/?i=((930/155)%5E(1/(2013-1995))+-1)+*+100" title="" target="">(930&#x2F;155)^(1&#x2F;(2013-1995)) - 1</a> &#x3D; 10.46%</p><p>即这套房产，在1995年到2013年这18年间，每年的收益率是10.46%</p><p>结语：学会复利公式之后，并不能帮大家赚钱，但能帮大家看别人赚了多少钱，可以说非常有用了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;年化收益率的概念随着余额宝的热潮已经非常普及了。当余额宝年化收益率是5%时，就表示100万本金一年能赚5万块，这是一个非常直观的投钱指标。那为什么叫年化收益率而不叫年收益率呢？因为真实收益率本身是在波动的，你今天的收益率，明天的收益率，今年的收益率，明年的收益率都是在波动而</summary>
      
    
    
    
    <category term="economic" scheme="https://www.cssass.com/categories/economic/"/>
    
    
    <category term="复利" scheme="https://www.cssass.com/tags/%E5%A4%8D%E5%88%A9/"/>
    
  </entry>
  
  <entry>
    <title>天命：响应式布局的单位——VW/VH</title>
    <link href="https://www.cssass.com/2016/12/30/%E5%A4%A9%E5%91%BD%EF%BC%9A%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%8D%95%E4%BD%8D%E2%80%94%E2%80%94VW-VH/"/>
    <id>https://www.cssass.com/2016/12/30/%E5%A4%A9%E5%91%BD%EF%BC%9A%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%8D%95%E4%BD%8D%E2%80%94%E2%80%94VW-VH/</id>
    <published>2016-12-30T05:22:11.000Z</published>
    <updated>2023-07-01T05:10:15.213Z</updated>
    
    <content type="html"><![CDATA[<p>本文最早发布于知乎的一个回答：<a href="https://www.zhihu.com/question/37179916/answer/101810379" title="" target="">vw相比rem，在实际开发中究竟有多大区别？</a><br>几年前，人们谈论响应式布局的时候，必会提到一个单位：rem，其基于rem的布局思路影响一直持续到今天。那么rem是否是最好的呢？有没有更合理的布局结局方案呢？以下是原文：</p><p>我认为基于vw开发布局比基于rem不知道要高明到哪里去了。</p><p>vw可以轻松搞定弹性布局，流体布局。而网上那些吹捧rem的文章，所用的响应式适配方案都是基于弹性布局的。流体布局？人家说了，流体布局不好，见 <a href="https://isux.tencent.com/web-app-rem.html" title="" target="">web app变革之rem</a></p><p>vw逻辑非常清晰，”1vw ＝ 1&#x2F;100th viewport width”，用viewport width的百分比来设置element width。rem是什么？“The font size of the root element”，就是说你用它来布局，就相当于用font size 来设置 width size，中间你要转一道。<br>基于以上，我也发出了题主的疑问，为什么rem这种单位会被用来布局，而vw这种天生的布局单位缺鲜有人关注？</p><p>所以今天深扒了一下关于这两个单位在 W3C组织 的邮件组里的讨论，<br>rem这个单位，我能找到的最早讨论是在2002年4月，一封比较各种样式语言的邮件中：<a href="http://lists.w3.org/Archives/Public/www-style/2002Apr/0010.html">http://lists.w3.org/Archives/Public/www-style/2002Apr/0010.html</a> ，</p><blockquote><p>CSS3 would just need a unit relative to the Root element’s EM – say, ‘rem’</p></blockquote><p>之后有理由相信，rem最晚在2003年8月，已经被讨论组内人士所公认，并有可能已处在 w3c 工作组成员的笔记之中：<a href="http://lists.w3.org/Archives/Public/www-style/2003Aug/0044.html">http://lists.w3.org/Archives/Public/www-style/2003Aug/0044.html</a></p><blockquote><p>According to my experience, when some authors look for exotic ways to define size of some element, it really comes to trying to define size of that element relative to viewport size. Nowadays, one has to use percentages and carefully compute size of every element from root to the element one wants to set size for. This is logical addition to ‘rem’ unit (root’s em).</p></blockquote><p>邮件的作者此时也提出了两个单位：</p><blockquote><p>vpw: viewport width<br>vph: viewport height</p></blockquote><p>仔细一看，这不就是现在的vw 和 vh 么。</p><p>其实，再早半年，也已经有人提出了与 vw 和 vh 接近的概念：<a href="http://lists.w3.org/Archives/Public/www-style/2003Feb/0110.html">http://lists.w3.org/Archives/Public/www-style/2003Feb/0110.html</a></p><blockquote><p>The unit should be relative to the screen (or paper) width.<br>The unit should be referenced to the preferred screen resolution.</p><p>I suggest those units:<br>sw8 &#x3D; (screen.width &#x2F; 800 ) px;<br>sw12 &#x3D; (screen.width &#x2F; 1200 ) px;<br>sw16 &#x3D; (screen.width &#x2F; 1600 ) px;<br>sw24 &#x3D; (screen.width &#x2F; 2400 ) px;</p></blockquote><p>2005年3月，从一封讨论CSS运算表达式的邮件里 <a href="http://lists.w3.org/Archives/Public/www-style/2005Mar/0057.html">http://lists.w3.org/Archives/Public/www-style/2005Mar/0057.html</a> 可以确定 vw 已基本被定下，同时被定下的还有vh 和 vm (也就是后来的vmin)：</p><blockquote><p>the working group recently decided to investigate the implications of allowing simple, linear expressions as values.</p><p>Some common cases can be done without expressions, by means of a few new units:</p><p>gd &#x3D; the grid unit from CSS3 Text<br>rem &#x3D; the font size of the root element<br>vw &#x3D; the viewport width (or 1&#x2F;100th of it)<br>vh &#x3D; the viewport height (or 1&#x2F;100th of it)<br>vm &#x3D; min(vw, vh)</p></blockquote><p>当然</p><blockquote><p>There is not even a draft yet, though.</p></blockquote><p>不过话音刚落，到了当年7月26日，working draft 发布： CSS3 Values and Units</p><p>此次是第二次发布CSS3 Values and Units草案，距离首次发布已经过去整整4年，显而易见： ren, vw, vh, vm 是同时进的草案。</p><p>之后，2012年3月8日，vm 更改为 vmin。2012年8月28日，发布Candidate Recommendation（备选标准），增加 vmax。截止到现在，CSS3 Values and Units依然处于备选标准阶段，并不是一个正式标准，CSS Values and Units Module Level 3。</p><p>但俨然它是一个事实标准，因为浏览器厂商从来不是等标准确定后才付之实施，否则就会落后于人。我猜也不乏浏览器厂家在事先实现了某个features，继而正式递交工作组要求成为标准的，当然大多数浏览器厂商本身就是标准制定组成员。所以，虽然同时进入标准，rem 和 vw 的命运还得看浏览器厂家们是否积极去实现。</p><p>我们来看看 rem 和 vw 在 Moliza 家的待遇：<br>2009-01-05：有用户提交bug要求支持rem：472195 – support css3 root em (‘rem’ or ‘re’) units<br>2009-07-11：有用户提交bug要求实现vw：503720 – Implement vw&#x2F;vh&#x2F;vmin&#x2F;vmax (viewport sizes) from CSS 3 Values and Units<br>相差半年<br>2010-1-21: Firefox3.6发布，支持rem：Firefox 3.6 for developers<br>2013-2-19: Firefox 19发布，支持vw：Firefox 19 for developers<br>晚了三年</p><p>其它各家皆是如此，厚此而薄彼，就导致了如下的支持度差异：<br>rem：</p><img src="https://pic2.zhimg.com/b4f035b1007996aba311cab004425179_b.png" class=""><p>vw:</p><img src="https://pic4.zhimg.com/a6df85f2f4c38db8ff30da6f5276362f_b.png" class=""><p>回到原题，vw被支持的太晚是其并不流行的根本原因，而当时移动端web app&#x2F;page的开发需求已经十分旺盛，弹性布局是一种不错的移动端界面兼容展现方式，对于rem机遇就此而来，便成为一个实现弹性布局效果的极佳方案。</p><p>其实看目前状况，对vw最不利的是Android Browser，据我调查Android Browser 4.4以下的还占全部Android Browser的 9% 左右, 这个量还是不容忽视的。</p><p>好在既然所有最新浏览器都已经支持，那么随着时间推移，相信未来vw必将会流行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文最早发布于知乎的一个回答：&lt;a href=&quot;https://www.zhihu.com/question/37179916/answer/101810379&quot; title=&quot;&quot; target=&quot;&quot;&gt;vw相比rem，在实际开发中究竟有多大区别？&lt;/a&gt;&lt;br&gt;几年前，人们</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="CSS3" scheme="https://www.cssass.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>Date对象初始化Month，Day参数的奇葩设定的解释</title>
    <link href="https://www.cssass.com/2014/08/16/Date%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96Month%EF%BC%8CDay%E5%8F%82%E6%95%B0%E7%9A%84%E5%A5%87%E8%91%A9%E8%AE%BE%E5%AE%9A%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
    <id>https://www.cssass.com/2014/08/16/Date%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96Month%EF%BC%8CDay%E5%8F%82%E6%95%B0%E7%9A%84%E5%A5%87%E8%91%A9%E8%AE%BE%E5%AE%9A%E7%9A%84%E8%A7%A3%E9%87%8A/</id>
    <published>2014-08-16T05:11:07.000Z</published>
    <updated>2023-07-01T07:13:56.351Z</updated>
    
    <content type="html"><![CDATA[<p>new一个Date对象时，当以年份Y，月份M，日期D为参数传入来设定的时候，我们会发现：月份M是从0开始的，而日期D却是从1开始的。<br>即：M:0是一月，1是二月，11是十二月，但D：1 是一号，2是二号，31是三十一号。<br>如下：</p><p><textarea class="runcode_text" id="runcode_48d55790-83a6-4858-a999-ec41debe3e2f"><script type="text/javascript">var t1 = new Date(2014,0,1).toLocaleString(),t2 = new Date(2014,1,2).toLocaleString(),t3 = new Date(2014,11,29).toLocaleString()document.write(2014,"&nbsp;",0,"&nbsp;",1,"<br />",t1,"<br /><br />");document.write(2014,"&nbsp;",1,"&nbsp;",2,"<br />",t2,"<br /><br />");document.write(2014,"&nbsp;",11,"&nbsp;",29,"<br />",t3,"<br /><br />");</script></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_48d55790-83a6-4858-a999-ec41debe3e2f');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_48d55790-83a6-4858-a999-ec41debe3e2f');" /></p><p>是不是觉得很别扭，很奇葩？</p><p>对于习惯了以“一月”称呼“January”，“二月”称呼“February”的人来说，让”0″和”一”对应，”1″和”二”对应肯定是超级别扭啊，<br>但对于计算机从业者来说倒合情合理，第一位都是0开始数的嘛。</p><p>那问题抛向了另一边，为什么Day又是从1开始呢？<br>那么我告诉你1Day其实根本不是数组的第一项，日期的初始也是0！<br>当1Day完成的时候，时间就已经过去了二十四小时，1Day已经结束了。<br>所以0Day才是days的开始，那么我们来看看0Day到底是什么时候，让我们从1Day开始往前回溯，其实我们将每一天的开始设在了前夜。<br>如果按小数来细分的话，每月1号的正午应该算是0.5号，而10号的下午6点就是九又四分之三号！</p><p><textarea class="runcode_text" id="runcode_e0417420-ed83-443c-bd97-f49c8a3af816"><script type="text/javascript">var t3 = new Date(2014,11,29).toLocaleString(),t2 = new Date(2014,1,2).toLocaleString(),t1 = new Date(2014,0,1).toLocaleString(),t0 = new Date(2014,0,0).toLocaleString();document.write(2014,"&nbsp;",11,"&nbsp;",29,"<br />",t3,"<br /><br />");document.write(2014,"&nbsp;",1,"&nbsp;",2,"<br />",t2,"<br /><br />");document.write(2014,"&nbsp;",0,"&nbsp;",1,"<br />",t1,"<br /><br />");document.write(2014,"&nbsp;",0,"&nbsp;",0,"<br />",t0,"<br /><br />");</script></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_e0417420-ed83-443c-bd97-f49c8a3af816');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_e0417420-ed83-443c-bd97-f49c8a3af816');" /></p><p>0Day的设计，其实还有一个巨大的好处，我们调用new Date就可以轻松拿到当月的最后一号，而不用你自己去考虑大小月、闰年2月。<br>如下：</p><p><textarea class="runcode_text" id="runcode_ecee6909-3ba1-418f-9cff-021590e65e43"><script type="text/javascript">var t1 = new Date(2014,1,0).toLocaleString(),t2 = new Date(2014,2,0).toLocaleString(),t3 = new Date(2014,3,0).toLocaleString(),t4 = new Date(2014,4,0).toLocaleString();document.write(t1,"<br />");document.write(t2,"<br />");document.write(t3,"<br />");document.write(t4,"<br />");</script></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_ecee6909-3ba1-418f-9cff-021590e65e43');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_ecee6909-3ba1-418f-9cff-021590e65e43');" /></p><p>全文结束。<br>插一个小问题，在知乎上看见有人提问 <a href="http://www.zhihu.com/question/24400532/answer/29267154" title="" target="">javascript里面为什么不提供date的格式化函数？</a> 其实在Firefox上是提供了一个toLocaleFormat方法的。</p><p><textarea class="runcode_text" id="runcode_d69ac47e-dcc8-43db-a736-f2c5f5e451f2"><script type="text/javascript">(function(){if(!new Date().toLocaleFormat) return alert("Date has no method 'toLocaleFormat'");var t1 = new Date().toLocaleFormat("%y/%m/%d");t2 = new Date("2015,2,14").toLocaleFormat("%y-%m-%d");t3 = new Date(1391012219050).toLocaleFormat();document.write(t1,"<br />");document.write(t2,"<br />");document.write(t3,"<br />");})();</script></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_d69ac47e-dcc8-43db-a736-f2c5f5e451f2');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_d69ac47e-dcc8-43db-a736-f2c5f5e451f2');" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;new一个Date对象时，当以年份Y，月份M，日期D为参数传入来设定的时候，我们会发现：月份M是从0开始的，而日期D却是从1开始的。&lt;br&gt;即：M:0是一月，1是二月，11是十二月，但D：1 是一号，2是二号，31是三十一号。&lt;br&gt;如下：&lt;/p&gt;
&lt;p&gt;&lt;textarea</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="JS" scheme="https://www.cssass.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Unicode中的Emoji表情字符</title>
    <link href="https://www.cssass.com/2014/05/09/Unicode%E4%B8%AD%E7%9A%84Emoji%E8%A1%A8%E6%83%85%E5%AD%97%E7%AC%A6/"/>
    <id>https://www.cssass.com/2014/05/09/Unicode%E4%B8%AD%E7%9A%84Emoji%E8%A1%A8%E6%83%85%E5%AD%97%E7%AC%A6/</id>
    <published>2014-05-09T03:37:28.000Z</published>
    <updated>2023-06-30T07:51:53.709Z</updated>
    
    <content type="html"><![CDATA[<p><textarea class="runcode_text" id="runcode_b96d530e-8b31-43b9-bc7e-8141d2cf6d22"><!DOCTYPE html><html><head><meta charset="UTF-8"/><title>Unicode6.0字符显示</title><style>*{padding:0;margin:0;}body{font-size:50px;padding:20px;}h3{padding:20px 10px;background:#eee;}p{word-wrap:break-word;border:1px solid #ccc; padding:10px;}</style><script src="/public/js/extend.js"></script><div id="showcode"></div><script>var code = "<h3>Emoticons</h3><p>";for(var i = 0x1f600 ; i <= 0x1f64f; i = i + 1 ){code += "&#" + i + ";";}code += "<h3>Miscellaneous Symbols And Pictographs</h3><p>";for(var i = 0x1F300 ; i <= 0x1F5FF; i = i + 1 ){code += "&#" + i + ";";}code += "<h3>Playing Cards</h3><p>";for(var i = 0x1F0A0 ; i <= 0x1F0FF; i = i + 1 ){code += "&#" + i + ";";}code += "<h3>Transport And Map symbols</h3><p>";for(var i = 0x1F680 ; i <= 0x1F6FF; i = i + 1 ){code += "&#" + i + ";";}code += "<h3>Dingbats</h3><p>";for(var i = 0x2700 ; i <= 0x27BF; i = i + 1 ){code += "&#" + i + ";";}code += "<h3>Miscellaneous Technical</h3><p>";for(var i = 0x2300 ; i <= 0x23ff; i = i + 1 ){code += "&#" + i + ";";}$id("showcode").insertAdjacentHTML("beforeend",code);</script></body></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_b96d530e-8b31-43b9-bc7e-8141d2cf6d22');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_b96d530e-8b31-43b9-bc7e-8141d2cf6d22');" /></p><p>附一个QQ表情库</p><p><textarea class="runcode_text" id="runcode_3d8fb288-360e-4834-889c-e6da5569a35f"><!doctype html><html><head><meta charset="UTF-8"/><title>QQ Emoticons</title><script src="/public/js/extend.js"></script><style>*{padding:0;margin:0;}img {padding:10px;margin:10px;border:3px double #eee;border-radius:8px;}</style></head><body><div id="showEmo"></div></body><script>var $id = function(o){return document.getElementById(o);};var Emo = {url : "http://ctc.qzonestyle.gtimg.cn/qzone/em/e",index : 0,removeArr : {205:300,371:500,778:829,954:1000,1012:1500,1503:2000,2074:2172,2325:2801,2804:3000,3079:3173,3200:4001,4021:4300,4302:4400,4411:6001,6096:7000,7450:10000,10075:100000,100179:100491,100730:110000,110157:120000,120043:121001,121036:326980,326981:327183,327184:327343,327570:327743,328710:332445},getEmoStr : function(start,num){var str = "";Emo.index = start + num;for(var i = start; i < Emo.index; i++){if(i in Emo.removeArr){Emo.index =  Emo.removeArr[i];str += "<br />";break;}str += "<img title="+i+" src=" + Emo.url + i + ".gif />";};return str;}};var showDIV = $id("showEmo");showDIV.insertAdjacentHTML("beforeend",Emo.getEmoStr(Emo.index, 1000));window.onscroll=function(){var scrollTop = document.body.scrollTop || document.documentElement.scrollTop,windowHeight = document.documentElement.clientHeight,documentHeight = document.body.offsetHeight;if(windowHeight + scrollTop > documentHeight - 50 ){showDIV.insertAdjacentHTML("beforeend",Emo.getEmoStr(Emo.index, 200));};};</script></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_3d8fb288-360e-4834-889c-e6da5569a35f');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_3d8fb288-360e-4834-889c-e6da5569a35f');" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;textarea class=&quot;runcode_text&quot; id=&quot;runcode_b96d530e-8b31-43b9-bc7e-8141d2cf6d22&quot;&gt;&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;/&gt;
&lt;t</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="unicode" scheme="https://www.cssass.com/tags/unicode/"/>
    
  </entry>
  
  <entry>
    <title>鲸鱼夫妇</title>
    <link href="https://www.cssass.com/2013/07/09/%E9%B2%B8%E9%B1%BC%E5%A4%AB%E5%A6%87/"/>
    <id>https://www.cssass.com/2013/07/09/%E9%B2%B8%E9%B1%BC%E5%A4%AB%E5%A6%87/</id>
    <published>2013-07-09T03:27:15.000Z</published>
    <updated>2023-07-01T07:19:15.439Z</updated>
    
    <content type="html"><![CDATA[<p>写了个小东西，用于展示JS语言中类的模拟。已发布到chrome应用商店：安装地址，可以在chrome浏览器上添加这个扩展应用</p><iframe src="/show/whale/index.html" width="95%" height="500" frameborder="0" loading="lazy" allowfullscreen></iframe><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">function inherit(klass,parent)&#123;</span><br><span class="line">function F()&#123;&#125;</span><br><span class="line">F.prototype = parent.prototype;</span><br><span class="line">klass.prototype = new F();</span><br><span class="line">klass.prototype.constructor = klass;</span><br><span class="line">return klass;</span><br><span class="line">&#125;</span><br><span class="line">function getRandInt(min, max) &#123;</span><br><span class="line">return (Math.random() * (max - min) + min) &gt;&gt; 0;</span><br><span class="line">&#125;</span><br><span class="line">var family = [];</span><br><span class="line">function Whale(options)&#123;</span><br><span class="line">var self = this;</span><br><span class="line">(function(options) &#123;</span><br><span class="line">self.option = &#123;</span><br><span class="line">size : [240, 120],</span><br><span class="line">pos : [0, 0],</span><br><span class="line">speed : [6, 2],</span><br><span class="line">spritX : [10, -3360],</span><br><span class="line">spritY : 0</span><br><span class="line">&#125;;</span><br><span class="line">extendCopy(options || &#123;&#125;, self.options);</span><br><span class="line">&#125;)();</span><br><span class="line">this.gender = &#x27;male&#x27;</span><br><span class="line">this.init();</span><br><span class="line">&#125;</span><br><span class="line">Whale.prototype = &#123;</span><br><span class="line">init : function()&#123;</span><br><span class="line">this.create();</span><br><span class="line">this.play();</span><br><span class="line">this.swim();</span><br><span class="line">family.push(this);</span><br><span class="line">&#125;,</span><br><span class="line">create : function()&#123;</span><br><span class="line">var that = this;</span><br><span class="line">var whaleBox = document.createElement(&quot;DIV&quot;);</span><br><span class="line">whaleBox.className = &quot;whale&quot;;</span><br><span class="line">whaleBox.style.width = this.option.size[0] + &quot;px&quot;;</span><br><span class="line">whaleBox.style.height = this.option.size[1] + &quot;px&quot;;</span><br><span class="line">document.body.appendChild(whaleBox);</span><br><span class="line">events.addEvent(whaleBox, &quot;mousedown&quot;, function()&#123;</span><br><span class="line">var e = arguments[0] || window.event;</span><br><span class="line">that._drag(e);</span><br><span class="line">&#125;);</span><br><span class="line">this.whaleBox = whaleBox;</span><br><span class="line">return this;</span><br><span class="line">&#125;,</span><br><span class="line">_swimTimer : null,</span><br><span class="line">swim : function()&#123;</span><br><span class="line">var that = this,</span><br><span class="line">pos = this.option.pos,</span><br><span class="line">speed = this.option.speed,</span><br><span class="line">step = [Math.abs(this.option.speed[0]), Math.abs(this.option.speed[1])],</span><br><span class="line">dir = [speed[0]/step[0], speed[1]/step[1]],</span><br><span class="line">size = this.option.size;</span><br><span class="line">var moveX = 0,</span><br><span class="line">moveY = 0;</span><br><span class="line">this._swimTimer = setInterval(function()&#123;</span><br><span class="line">moveX = dir[0] * getRandInt(1,step[0]);</span><br><span class="line">moveY = dir[1] * getRandInt(1,step[1]);</span><br><span class="line">if(pos[0] + moveX &gt; Whale.windowSize[0] - size[0] || pos[0] + moveX &lt; 0 )&#123;</span><br><span class="line">//边境时候掉头</span><br><span class="line">moveX = 0;</span><br><span class="line">speed[0] = - speed[0];</span><br><span class="line">dir[0] = - dir[0];</span><br><span class="line">that.option.spritY += dir[0] * size[1];</span><br><span class="line">that.play();</span><br><span class="line">&#125;</span><br><span class="line">if(pos[1] + moveX &gt; Whale.windowSize[1] - size[1] || pos[1] + moveY &lt; 0 )&#123;</span><br><span class="line">moveY = 0;</span><br><span class="line">speed[1] = - speed[1];</span><br><span class="line">dir[1] = - dir[1];</span><br><span class="line">&#125;</span><br><span class="line">pos[0] += moveX;</span><br><span class="line">pos[1] += moveY;</span><br><span class="line">that.whaleBox.style.left = pos[0] + &quot;px&quot;;</span><br><span class="line">that.whaleBox.style.top = pos[1] + &quot;px&quot;;</span><br><span class="line">&#125;,200);</span><br><span class="line">&#125;,</span><br><span class="line">hook : function()&#123;</span><br><span class="line"> clearInterval(this._swimTimer);</span><br><span class="line">&#125;,</span><br><span class="line">_playTimer : null,</span><br><span class="line">play : function()&#123;</span><br><span class="line">var that = this,</span><br><span class="line">s = Math.abs(this.option.speed[0]),</span><br><span class="line">spritX = this.option.spritX,</span><br><span class="line">x = spritX[0], //sprite开始位置</span><br><span class="line">y = this.option.spritY;</span><br><span class="line">clearInterval(this._playTimer);</span><br><span class="line">this._playTimer = setInterval(function()&#123;</span><br><span class="line">x = (x &lt;= spritX[1]) ? spritX[0] : x;</span><br><span class="line">that.whaleBox.style.cssText += &quot;background-position:&quot;+x+&quot;px &quot;+ y +&quot;px;&quot;;</span><br><span class="line">x -= that.option.size[0];</span><br><span class="line">&#125;,1000/s/1);</span><br><span class="line">&#125;,</span><br><span class="line">_drag : function(e)&#123;</span><br><span class="line">var that = this;</span><br><span class="line">var whaleBox = that.whaleBox;</span><br><span class="line">var sX = whaleBox.offsetLeft,</span><br><span class="line">sY = whaleBox.offsetTop,</span><br><span class="line">dx = e.clientX,</span><br><span class="line">dy = e.clientY;</span><br><span class="line">that.hook();</span><br><span class="line">whaleBox.style.zIndex = Whale.zIndex++;</span><br><span class="line">events.addEvent(document, &#x27;mousemove&#x27;, dragHandle);</span><br><span class="line">events.addEvent(document, &#x27;mouseup&#x27;, cancelDragHandle);</span><br><span class="line">var largeL = Whale.windowSize[0] -  this.option.size[0],</span><br><span class="line">largeT = Whale.windowSize[1] -  this.option.size[1];</span><br><span class="line">function dragHandle() &#123;</span><br><span class="line">var e = arguments[0] || window.event;</span><br><span class="line">var oX = sX + (e.clientX - dx),</span><br><span class="line">oY = sY + (e.clientY - dy);</span><br><span class="line">if(oX &gt; largeL || oX &lt; 0)&#123;</span><br><span class="line">oX = (oX &lt; 0) ? 0 : largeL</span><br><span class="line">&#125;</span><br><span class="line">if(oY &gt; largeT || oY &lt; 0)&#123;</span><br><span class="line">oY = (oY &lt; 0) ? 0 : largeT</span><br><span class="line">&#125;</span><br><span class="line">that.option.pos[0] = oX;</span><br><span class="line">that.option.pos[1] = oY;</span><br><span class="line">whaleBox.style.left = oX + &quot;px&quot;;</span><br><span class="line">whaleBox.style.top = oY + &quot;px&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">function cancelDragHandle() &#123;</span><br><span class="line">events.removeEvent(document, &#x27;mousemove&#x27;, dragHandle);</span><br><span class="line">events.removeEvent(document, &#x27;mouseup&#x27;, cancelDragHandle);</span><br><span class="line">that.swim();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Whale.zIndex = 1000;</span><br><span class="line">Whale.windowSize = [document.documentElement.offsetWidth, Math.max(document.documentElement.clientHeight, document.body.offsetHeight)];</span><br><span class="line">Whale.mating = function()&#123;</span><br><span class="line">for(var i= 0 ; i&lt; family.length; i++)&#123;</span><br><span class="line">if(family[i].gender !== &quot;male&quot;) continue;</span><br><span class="line">for(var j= 0; j&lt; family.length; j++)&#123;</span><br><span class="line">if(family[j].gender !== &quot;female&quot;) continue;</span><br><span class="line">if(Math.abs(family[i].option.pos[0] - family[j].option.pos[0]) &lt; 10 &amp;&amp; Math.abs(family[i].option.pos[1] - family[j].option.pos[1]) &lt; 10 &amp;&amp; !family[j].option.gestation)&#123;</span><br><span class="line">(function(j)&#123;</span><br><span class="line">family[j].option.gestation = true;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">family[j].option.gestation = false;</span><br><span class="line">&#125;,5 * 60 * 1000);</span><br><span class="line">new WhaleBaby(&#123;pos:[family[j].option.pos[0] + 80, family[j].option.pos[1] + 30]&#125;);</span><br><span class="line">&#125;)(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">function WhaleLady(options)&#123;</span><br><span class="line">var self = this;</span><br><span class="line">(function(options) &#123;</span><br><span class="line">self.option = &#123;</span><br><span class="line">size : [210, 100],</span><br><span class="line">pos : [80, 200],</span><br><span class="line">speed : [4, -2],</span><br><span class="line">spritX : [10, -2940],</span><br><span class="line">spritY : -300</span><br><span class="line">&#125;;</span><br><span class="line">extendCopy(options || &#123;&#125;, self.options);</span><br><span class="line">&#125;)();</span><br><span class="line">this.gender = &quot;female&quot;;</span><br><span class="line">this.gestation = false;</span><br><span class="line">this.init();</span><br><span class="line">&#125;</span><br><span class="line">function WhaleBaby(options)&#123;</span><br><span class="line">var self = this;</span><br><span class="line">(function(options) &#123;</span><br><span class="line">self.option = &#123;</span><br><span class="line">size : [120, 60],</span><br><span class="line">pos : [0, 100],</span><br><span class="line">speed : [7, -3],</span><br><span class="line">spritX : [2, -1650],</span><br><span class="line">spritY : -600</span><br><span class="line">&#125;;</span><br><span class="line">extendCopy(options || &#123;&#125;, self.option);</span><br><span class="line">&#125;)(options);</span><br><span class="line">this.init();</span><br><span class="line">&#125;</span><br><span class="line">inherit(WhaleLady, Whale);</span><br><span class="line">inherit(WhaleBaby, WhaleLady);</span><br><span class="line">var bb = new WhaleLady();</span><br><span class="line">var aa = new Whale();</span><br><span class="line">setInterval(Whale.mating,1000);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写了个小东西，用于展示JS语言中类的模拟。已发布到chrome应用商店：安装地址，可以在chrome浏览器上添加这个扩展应用&lt;/p&gt;
&lt;iframe src=&quot;/show/whale/index.html&quot; width=&quot;95%&quot; height=&quot;500&quot; framebor</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="JS" scheme="https://www.cssass.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>使用Threejs制作3D螺旋线</title>
    <link href="https://www.cssass.com/2013/02/06/%E4%BD%BF%E7%94%A8Threejs%E5%88%B6%E4%BD%9C3D%E8%9E%BA%E6%97%8B%E7%BA%BF/"/>
    <id>https://www.cssass.com/2013/02/06/%E4%BD%BF%E7%94%A8Threejs%E5%88%B6%E4%BD%9C3D%E8%9E%BA%E6%97%8B%E7%BA%BF/</id>
    <published>2013-02-06T03:31:36.000Z</published>
    <updated>2023-07-01T05:55:53.209Z</updated>
    
    <content type="html"><![CDATA[<p>做了一个3D螺旋线的生成器</p><p><textarea class="runcode_text" id="runcode_7a68495b-bfb2-48aa-b16a-70c41daf7a68"><!DOCTYPE html><html><head><meta charset="utf-8"><title>Threejs制作3D螺旋线</title><style>*{padding:0;margin:0;}body{background:#333;color:#fff;}.controlBar{position:absolute;}#control ul{width:150px;float:left;list-style:none;}#control b{position:relative;display:inline-block;width:120px;height:5px;font-size:0;line-height:0;background:#fff;border:1px solid #aaa;border-radius:2px;}#control i{position:absolute;cursor:pointer;top:-4px;left:50%;width:10px;height:10px;margin-left:-4px;border:1px solid #d3d3d3;background:#ececec;border-radius:2px;}#control i:hover{border:1px solid #999;background:#dcdcdc;}</style><script src="/public/js/extend.js"></script><script src="/public/js/three.min.js"></script></head><body><div class="controlBar"><div id="control"><ul><li>x:  <b class='range'><i data-value='85.2'>&nbsp;</i></b></li><li>y:  <b class='range'><i data-value='205.2'>&nbsp;</i></b></li><li>z:  <b class='range'><i data-value='-64.8'>&nbsp;</i></b></li></ul><ul><li>x:  <b class='range'><i data-value='60'>&nbsp;</i></b></li><li>y:  <b class='range'><i data-value='-49.8'>&nbsp;</i></b></li><li>z:  <b class='range'><i data-value='184.8'>&nbsp;</i></b></li></ul><ul><li>x:  <b class='range'><i data-value='225'>&nbsp;</i></b></li><li>y:  <b class='range'><i data-value='-195'>&nbsp;</i></b></li><li>z:  <b class='range'><i data-value='195'>&nbsp;</i></b></li></ul></div><button onclick="Producer.createPoints()">增加操作点</button></div><script>var controlElm = $id("control"),iElm = $tag("i", controlElm);for(var i = 0; i < iElm.length; i++){iElm[i].style.left = (iElm[i].dataset['value'] - 0 + 300) * 100 /600 + "%";}var Producer = {points : [],getPoints : function(){Producer.points = [];var UL = $tag("UL", controlElm), item, jsondata;for(var i = 0 ; i <UL.length; i++){item =  $tag("i",UL[i]);jsondata = {x : item[0].dataset['value']-0,y : item[1].dataset['value']-0,z : item[2].dataset['value']-0,}Producer.points.push(jsondata);}},createPoints : function(){$id("control").insertAdjacentHTML('beforeEnd',$tag("UL",$id("control"))[0].outerHTML);},changePoints : function(o,e){var l = 600;if(!window.event) {e.preventDefault();}var tX = o.offsetLeft,dx = e.clientX;events.addEvent(document,'mousemove',mouseMove);events.addEvent(document,'mouseup',mouseUp);function mouseMove(){var e = arguments[0] || window.event;var len = tX + e.clientX - dx + 8, val;if(len >=0 && len <= 120){var rat = (len / 120) * 100;o.style.left = rat+ "%";val = l * Math.round((rat - 50)*10)/1000;o.dataset['value'] = val;o.title = val;}if(window.event) e.returnValue=false;}function mouseUp(){events.removeEvent(document,'mousemove',mouseMove);events.removeEvent(document,'mouseup',mouseUp);spiralDemo.init().animate();}}};function Spiral3D(){this.width = Math.max(1000, document.documentElement.offsetWidth);this.height = 800;this.camera = new THREE.PerspectiveCamera( 33, this.width / this.height, 1, 10000);this.scene = new THREE.Scene();this.renderer = null;this.create();}Spiral3D.prototype = {create : function(){try{this.renderer = new THREE.WebGLRenderer( { antialias: true } ); //webgl}catch(e){this.renderer = new THREE.CanvasRenderer(); //canvas}this.renderer.setSize( this.width, this.height);document.body.appendChild( this.renderer.domElement );this.init();return this;},init : function() {this.scene = new THREE.Scene();this.stop();Producer.getPoints();var spline = new THREE.Spline( Producer.points ),  //以关键点创建曲线geometry = new THREE.Geometry(),material = new THREE.LineBasicMaterial( { color: 0xffffff, opacity: 1, linewidth: 1, vertexColors: THREE.VertexColors } );//自动补全曲线点for ( var i =0, position, l = Producer.points.length * 7; i < l; i ++ ) {position = spline.getPoint( i/l );geometry.vertices[ i ] = new THREE.Vector3( position.x, position.y, position.z );geometry.colors[ i ] = new THREE.Color( 0x00ffff );geometry.colors[ i ].setHSV( ( 100 + position.x ) / 400 * i/8, ( 200 + position.x ) / 400, ( 250 + position.x ) / 300);}//创建100条线for(var line, i=0, l = 100 ; i<l; i++){line = new THREE.Line(geometry,  material);line.position = {x: 0, y: 0, z: 0};if(i > 0) {line.rotation.y = Math.PI * 2 * (i/l);}this.scene.add( line ); //将显示对象加入场景}return this;},render : function() {var timer = Date.now() * 0.0005;this.camera.position.x = Math.cos( timer ) * 500;this.camera.position.z = Math.sin( timer ) * 500;this.camera.lookAt( this.scene.position );this.renderer.render( this.scene, this.camera ); //使用渲染器return this;},_reqID : {},animate : function() {var that = this;var _loop = function(){that._reqID = requestAnimationFrame( _loop );that.render();}_loop();return this;},stop : function(){var that = this;cancelAnimationFrame(that._reqID);}}var spiralDemo = new Spiral3D();spiralDemo.animate();events.delegate(controlElm, 'i', 'mousedown',function(){var e = arguments[0] || window.event,target = e.srcElement || e.target;Producer.changePoints(target,e);});</script></body></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_7a68495b-bfb2-48aa-b16a-70c41daf7a68');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_7a68495b-bfb2-48aa-b16a-70c41daf7a68');" /></p><p>配套做一个动画效果：</p><p><textarea class="runcode_text" id="runcode_e9007e32-34da-4f02-8bc2-e7e642df3fc1"><!DOCTYPE html><html><head><meta charset="utf-8"><title>Threejs 3D lines</title><style>*{padding:0;margin:0;}body{background:#333;color:#fff;overflow:hidden;}</style><script src="/public/js/extend.js"></script><script src="/blog/resource/threejs/three.min.js"></script></head><body><script>var Producer = {points : [{x : 85.2,y : 205.2,z : -64.8,a : 1,b : 1,c : 1},{x : 60,y : -49.8,z : 184.8,a : 1,b : 1,c : 2},{x : 225,y : -195,z : 195,a : 1,b : 2,c : 1},{x : 40,y : -40.8,z : 114.8,a : 2,b : 1,c : 1},{x : 85.2,y : 105.2,z : -24.8,a : 2,b : 1,c : 1},{x : 85.2,y : 205.2,z : -64.8,a : 1,b : 1,c : 1}],changePoints : function(){var points = Producer.points;for(var i = 0 ; i < points.length; i++){item =  points[i];if(item.x < -250 || item.x > 250) item.a = -item.a;if(item.y < -250 || item.y > 250) item.b = -item.b;if(item.z < -250 || item.z > 250) item.c = -item.c;item.x -= item.a,item.y -= item.b,item.z -= item.c}spiralDemo.init().animate();}};function Spiral3D(){this.width = document.documentElement.offsetWidth;this.height = Math.max(document.documentElement.clientHeight,document.body.offsetHeight);this.camera = new THREE.PerspectiveCamera( 33, this.width / this.height, 1, 10000);this.scene = new THREE.Scene();this.renderer = null;this.create();}Spiral3D.prototype = {create : function(){try{this.renderer = new THREE.WebGLRenderer( { antialias: true } ); //webgl}catch(e){this.renderer = new THREE.CanvasRenderer(); //canvas}this.renderer.setSize( this.width, this.height);document.body.appendChild( this.renderer.domElement );this.init();return this;},init : function() {this.scene = new THREE.Scene();this.stop();var spline = new THREE.Spline( Producer.points ),  //以关键点创建曲线geometry = new THREE.Geometry(),material = new THREE.LineBasicMaterial( { color: 0xffffff, opacity: 1, linewidth: 1, vertexColors: THREE.VertexColors } );//自动补全曲线点for ( var i =0, position, l = Producer.points.length * 7; i < l; i ++ ) {position = spline.getPoint( i/l );geometry.vertices[ i ] = new THREE.Vector3( position.x, position.y, position.z );geometry.colors[ i ] = new THREE.Color( 0x00ffff );geometry.colors[ i ].setHSV( ( 100 + position.x ) / 400 * i/8, ( 200 + position.x ) / 400, ( 250 + position.x ) / 300);}//创建100条线for(var line, i=0, l = 100 ; i<l; i++){line = new THREE.Line(geometry,  material);line.position = {x: 0, y: 0, z: 0};if(i > 0) {line.rotation.y = Math.PI * 2 * (i/l);}this.scene.add( line ); //将显示对象加入场景}return this;},render : function() {var timer = Date.now() * 0.0005;this.camera.position.x = Math.cos( timer ) * 500;this.camera.position.z = Math.sin( timer ) * 500;this.camera.lookAt( this.scene.position );this.renderer.render( this.scene, this.camera ); //使用渲染器return this;},_reqID : {},animate : function() {var that = this;var _loop = function(){that._reqID = requestAnimationFrame( _loop );that.render();}_loop();return this;},stop : function(){var that = this;cancelAnimationFrame(that._reqID);}};var spiralDemo = new Spiral3D();spiralDemo.animate();setInterval(Producer.changePoints,50);</script></body></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_e9007e32-34da-4f02-8bc2-e7e642df3fc1');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_e9007e32-34da-4f02-8bc2-e7e642df3fc1');" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;做了一个3D螺旋线的生成器&lt;/p&gt;
&lt;p&gt;&lt;textarea class=&quot;runcode_text&quot; id=&quot;runcode_7a68495b-bfb2-48aa-b16a-70c41daf7a68&quot;&gt;&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="3D" scheme="https://www.cssass.com/tags/3D/"/>
    
    <category term="threejs" scheme="https://www.cssass.com/tags/threejs/"/>
    
  </entry>
  
  <entry>
    <title>Metro风混搭瀑布流</title>
    <link href="https://www.cssass.com/2012/12/09/Metro%E9%A3%8E%E6%B7%B7%E6%90%AD%E7%80%91%E5%B8%83%E6%B5%81/"/>
    <id>https://www.cssass.com/2012/12/09/Metro%E9%A3%8E%E6%B7%B7%E6%90%AD%E7%80%91%E5%B8%83%E6%B5%81/</id>
    <published>2012-12-09T05:06:11.000Z</published>
    <updated>2023-07-01T07:56:50.010Z</updated>
    
    <content type="html"><![CDATA[<p>去年做了一个自号“ 格子块的智能堆砌 ”的效果, 当时瀑布流已激发了国内的第一批模仿者，微软的Merto也刚震撼了设计界。</p><p>今天把原来的效果改动优化了下，打造一个Metro风混搭瀑布流。</p><p><textarea class="runcode_text" id="runcode_dda23763-5243-4a06-bb4b-ec43a12397e9"><!doctype html><html><head><meta charset="UTF-8" /><title>Metro风兼搭瀑布流</title><style>body{background:#000;}.myMetro{position:relative;overflow:hidden;zoom:1;margin:0 auto;}.MBox{float:left;vertical-align:middle;}.widgetBox{position:relative;display:block;overflow:hidden;width:180px;height:160px;}</style><script src="/public/js/extend.js"></script><script>/* 格子排序 */var metro = {};metro.init=function(wrap){metro.gen={w:190,h:170};metro.wrap = wrap;metro.sizeArray= []; //格子,[1,2]就表示1X2的大格子metro.preset();metro.putData(wrap);};metro.preset = function(){metro.nameSpace= {};metro.maxY = -1;metro.basePos = {x:0, y:0};metro.memory = {flag:Infinity, x: Infinity, y:Infinity};metro.row = document.documentElement.offsetWidth / metro.gen.w >> 0;metro.wrap.style.width = metro.row * metro.gen.w + "px";};metro.resort=function(){metro.preset();metro.mbox = $class("MBox");metro.sort(metro.sizeArray);};metro.putData = function(list){(function setBig(){  //大格子初始化设置 var bigBox = $class("bigBox",list);   if(bigBox.length==0) return false;var i = 0, nx, ny, bigBoxCont;while(i < bigBox.length){bigBoxCont =  $class("innerBox",bigBox[i]);nx = Math.floor(bigBoxCont[0].offsetWidth / metro.gen.w); //bigBox横向占的块数ny = Math.floor(bigBoxCont[0].offsetHeight / metro.gen.h);bigBox[i].style.width = nx*metro.gen.w - 10 + 'px' ;bigBox[i].style.height = ny*metro.gen.h - 10 + 'px' ;i++;}})();metro.mbox = $class("MBox",list);var i = 0 , nx, ny, tempSizeArray = [];while( i < this.mbox.length){if( $class("bigBox",this.mbox[i]).length > 0 ){nx = Math.ceil(this.mbox[i].offsetWidth / this.gen.w);nx = (nx > this.row) ? this.row : nx; //bigBox宽度尺寸过大ny = Math.ceil(this.mbox[i].offsetHeight / this.gen.h);tempSizeArray.push([nx,ny]);}else{tempSizeArray.push([1,1]);}i++;}this.sizeArray = this.sizeArray.concat(tempSizeArray);metro.sort(tempSizeArray);}metro.sort = function(size){var x = metro.basePos.x,y = metro.basePos.y,memory = metro.memory,name;for(var n=0; n < size.length ; n++){if(memory.flag == 0){x = memory.x;y = memory.y;}memory.flag --;if(x > metro.row-1){ //换行x = 0;y ++;}name = x+'_'+y;  //对象属性名（反映占领的格子）if(name in this.nameSpace) {  //判断属性名是否存在n--;x++;memory.flag < Infinity && memory.flag++;continue;}if(size[n][0] * size[n][1] == 1){  //普通格子metro.nameSpace[name]=[x,y];  //项值（反映坐标值）setPos(x,y,n);x++;}else{  //大格子if(beOver(x,y,size[n])) {if(memory.y > y){memory.y = y;memory.x = x;}if(memory.y < Infinity) memory.flag = 1;n--;x++;continue;}metro.nameSpace[name] = [x,y];setPos(x,y,n);hold(x,y,size[n]);x += size[n][0];}if(memory.flag == -1) memory = {flag:Infinity ,x: Infinity, y:Infinity};metro.maxY = Math.max(metro.maxY, y + size[n][1]);}metro.basePos = {"x":x,"y":y}metro.memory = memory;metro.wrap.style.height= metro.gen.h * metro.maxY +'px';function beOver(x,y,item){  //判断是否会重叠var name;if(x + item[0] > metro.row) return true; //超出显示范围for(var k=1; k<item[1]; k++){name=x+'_'+(y-0+k);if(name in metro.nameSpace) return true; //左侧一列有无重叠}for(k=1; k<item[0]; k++){name=(x-0+k)+'_'+y;if(name in metro.nameSpace) return true; //上侧一行有无重叠}return false;};function hold(x,y,item){  //大格子多占的位置for(var t=0; t < item[0]; t++) {for(var k=0; k < item[1]; k++){name = (x+t)+'_'+(y+k);if(t==0 && k==0)   continue;metro.nameSpace[name] = 0;   //多占的格子无坐标值}}};function setPos(x,y,n){var left = metro.gen.w * x,top = metro.gen.h * y;metro.mbox[n].style.cssText += "position:absolute;left:"+ left +"px;top:" + top + "px;";}};</script></head><body><div id="myMetro" class="myMetro"></div><script>//随机数据var myMetro = $id("myMetro"),colorList = ['f4b300','78ba00','2673ec','ae113d','632f00','b01e00','4e0038','c1004f','7200ac','2d004e','006ac1','001e4e','008287','004d60','004a00','00c13f','15992a','ff981d','e56c19','b81b1b','ff1d77','b81b6c','aa40ff','691bb8','1faeff','1b58b8','56c5ff','569ce3','00d8cc','00aaaa','91d100','b81b6c','e1b700','d39d09','ff76bc','e064b7','00a4a4','ff7d23','4cafb5','044d91','832772','d15a44','de971b','017802','6e2ea0'],color = colorList[0];function createTestData(n){var spanWrap = document.createElement("span"),content = "";for(i = 0; i < n; i++) {color = colorList[(colorList.length * Math.random())>>0];if(!(Math.random()*3 >> 0)){ //输出大模块测试数据。宽高在一个范围内都是随意的，未做其他限制height = Math.floor(Math.random()*320 + 160);width = Math.floor(Math.random()*360 + 180);content += '<div class="MBox" style="background:#'+color+'"><div class="bigBox" ><a href="http://www.cssass.com" target="_blank" style="width:' + width +'px;height:' + height +'px;top:'+(-height%170)/2+'px;left:'+(-width%190)/2+'px;" class="widgetBox innerBox"></a></div></div>';}else{ //输出普通模块数据content += '<div class="MBox" style="background:#'+color+'"><a href="http://www.cssass.com" target="_blank" class="widgetBox" ></a></div>';}};spanWrap.innerHTML = content;myMetro.appendChild(spanWrap);return spanWrap;}window.onload = function(){createTestData(35);metro.init(myMetro);};window.onresize = function(){metro.resort(myMetro);};window.onscroll=function(){var scrollTop = document.body.scrollTop || document.documentElement.scrollTop,windowHeight = document.documentElement.clientHeight,documentHeight = document.body.offsetHeight;if(windowHeight + scrollTop > documentHeight - 50){metro.putData(createTestData(15));}}</script></body></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_dda23763-5243-4a06-bb4b-ec43a12397e9');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_dda23763-5243-4a06-bb4b-ec43a12397e9');" /></p><p>应大家要求，我将主要的sort方法取出来，再做个简单demo</p><p><textarea class="runcode_text" id="runcode_534ac67a-f101-44e2-a9ce-35f40b626459"><!doctype html><html><head><meta charset="UTF-8" /><title>CSSASS</title></head><body></body><script>var metro = {    //初始化数据。表示格子大小：1*1，1*2，2*3...    sizeArray : [[1, 1], [1, 2], [2, 1], [2, 3], [1, 1], [1, 2], [1, 1], [2, 2], [1, 1]],    //单元格尺寸    gen: {        w: 200,        h: 180    },    //nameSpace的key用于判断对应的坐标位置有没被占有,我们就是要保证key是唯一的。而value就是最终设置的坐标了。    nameSpace: {        /* 1_0: [1,0] */    }};metro.init = function () {    metro.row = 1000 / metro.gen.w >> 0; //一行最多能排下的单元格个数/ 测试宽度以1000px计。    metro.sort(metro.sizeArray);};metro.sort = function (size) {    var x = 0,        y = 0,        memory = {            flag: Infinity,            x: Infinity,            y: Infinity        },        name;    for (var n = 0; n < size.length; n++) {        if (memory.flag == 0) {            x = memory.x;            y = memory.y;        }        memory.flag--;        if (x > metro.row - 1) { //换行            x = 0;            y ++;        }        name = x + '_' + y; //对象属性名（反映占领的格子）        if (name in this.nameSpace) { //判断属性名是否存在            n --;            x ++;            memory.flag < Infinity && memory.flag++;            continue;        }        if (size[n][0] * size[n][1] == 1) { //普通格子            metro.nameSpace[name] = [x, y]; //项值（反映坐标值）            LOG(x, y, n, name, metro.nameSpace[name]); /* 显示及打印信息 */            x++;        } else { //大格子            if (beOver(x, y, size[n])) {                if (memory.y > y) {                    memory.y = y;                    memory.x = x;                }                if (memory.y < Infinity) memory.flag = 1;                n --;                x ++;                continue;            }            metro.nameSpace[name] = [x, y];            LOG(x, y, n, name, metro.nameSpace[name]); /* 显示及打印信息 */            hold(x, y, n);            x += size[n][0];        }        if (memory.flag == -1) memory = {            flag: Infinity,            x: Infinity,            y: Infinity        };    };    function beOver(x, y, item) { //判断是否会重叠        var name;        if (x + item[0] > metro.row) return true; //超出显示范围        for (var k = 1; k < item[1]; k++) {            name = x + '_' + (y - 0 + k);            if (name in metro.nameSpace) return true; //左侧一列有无重叠        }        for (k = 1; k < item[0]; k++) {            name = (x - 0 + k) + '_' + y;            if (name in metro.nameSpace) return true; //上侧一行有无重叠        }        return false;    };    function hold(x, y, n) { //大格子多占的位置        var item = metro.sizeArray[n];        for (var t = 0; t < item[0]; t++) {            for (var k = 0; k < item[1]; k++) {                name = (x + t) + '_' + (y + k);                if (t == 0 && k == 0) continue;                metro.nameSpace[name] = 0; //多占的格子无坐标值                LOG_2(n ,name);            }        }    };};metro.init();function LOG(x, y, n, key) {    //用于显示    var left = metro.gen.w * x,        top = metro.gen.h * y,        width = metro.sizeArray[n][0] * metro.gen.w,        height = metro.sizeArray[n][1] * metro.gen.h;    var box = document.createElement("div");    box.id = "ID" + n;    box.innerHTML = "<h3>" + n +"</h3>" + key + ":(" + metro.nameSpace[key] + ")<br/>";    box.style.cssText = "position:absolute;border:1px solid #333;left:" + left + "px;top:" + top + "px;width:" + width + "px;height:" + height + "px;";    document.body.appendChild(box);}function LOG_2(n, key){    //大格子多占位置的信息。    document.getElementById("ID" + n).innerHTML +=  key + ":(" + metro.nameSpace[key] + ")<br/>";}</script></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_534ac67a-f101-44e2-a9ce-35f40b626459');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_534ac67a-f101-44e2-a9ce-35f40b626459');" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;去年做了一个自号“ 格子块的智能堆砌 ”的效果, 当时瀑布流已激发了国内的第一批模仿者，微软的Merto也刚震撼了设计界。&lt;/p&gt;
&lt;p&gt;今天把原来的效果改动优化了下，打造一个Metro风混搭瀑布流。&lt;/p&gt;
&lt;p&gt;&lt;textarea class=&quot;runcode_text</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="JS" scheme="https://www.cssass.com/tags/JS/"/>
    
    <category term="Metro" scheme="https://www.cssass.com/tags/Metro/"/>
    
  </entry>
  
  <entry>
    <title>canvas模拟繁花曲线规</title>
    <link href="https://www.cssass.com/2012/12/05/canvas%E6%A8%A1%E6%8B%9F%E7%B9%81%E8%8A%B1%E6%9B%B2%E7%BA%BF%E8%A7%84/"/>
    <id>https://www.cssass.com/2012/12/05/canvas%E6%A8%A1%E6%8B%9F%E7%B9%81%E8%8A%B1%E6%9B%B2%E7%BA%BF%E8%A7%84/</id>
    <published>2012-12-05T02:56:41.000Z</published>
    <updated>2023-06-30T07:54:00.368Z</updated>
    
    <content type="html"><![CDATA[<p>不算难，就是几个相对运动。</p><p><textarea class="runcode_text" id="runcode_0129edb2-0b68-40ba-823c-05255b250beb"><!doctype html><html><head><meta charset='UTF-8' /><title>繁花曲线规</title><style>*{padding:0;margin:0;}body{background:#eee;overflow-x:hidden;}#operationBar{position: fixed;z-index:10000;bottom:0;width:100%;text-align:center;background:#FBFDFE;border-top:2px solid #CC0F16;padding:5px 0;}.optText{width:35px;}.dialog_Wrap{background:#666;border: 1px solid #585858;border-top:0;border-radius: 0 0 8px 8px;box-shadow: 1px 1px 2px #aaa; overflow: hidden;}.dialog_Head{background:#000;height:26px;line-height:26px;padding: 0 5px;border-top:2px solid #CC0F16;cursor:move;color:#fff;font-size:12px;}.dialog_close{text-decoration:none;color:#fff; display:inline-block;width:15px;height:15px;font-size:12px;text-align:center;line-height:15px;font-family:'Comic Sans MS';}.dialog_Head .dialog_Opts{position:absolute;right:5px;top:0;height:21px;cursor:default;}.dialog_Body{overflow:auto;}</style><script src="/public/js/extend.js"></script><script src="/public/js/litewin.js"></script></head><body><div id="operationBar"><label><input class="opt" id="showCricle" type="checkbox" />圈</label><label><input class="opt" id="showLine" type="checkbox" checked/>线</label><label><input class="opt" id="showPoint" type="checkbox" />点</label><label><input class="opt" id="showColor" type="checkbox" checked />变色</label><label><input class="opt" id="isRefresh" type="checkbox" />刷新</label><label>外圈半径:<input class="opt optText" id="bigRadius" type="text" value="133" /></label><label>内圈半径:<input class="opt optText" id="smallRadius" type="text" value="140" /></label><label>线长:<input class="opt optText" id="lineLength" type="text" value="123" /></label><label><input id="runBtn" type="button" value="新建"/></label></div></body><script>function Toy(options){this.setOptions(options);this.createPad();this.draw(true);}Toy.prototype = {setOptions: function(options) {this.options = {R:133, //大圈半径r:140, //小圈半径l:123, //线长showPoint: false, //显示小点showCricle: false, //显示小圈showLine: true, //显示线条isRefresh: false, //每次清屏showColor : true, //颜色变化count : 1500 //绘制次数};extendCopy(options || {}, this.options);//实际占用区域半径的计算var delta = 0;if(this.options.R > this.options.r){delta = (this.options.r > this.options.l) ? 0 : this.options.l - this.options.r;this.radius = this.options.R + delta;}else{delta = (this.options.r > this.options.l) ? this.options.r - this.options.R : this.options.l - this.options.R;this.radius = this.options.r + delta;}this.radius += 10;this.color = {r : 0,g : 0,b : 255,a : 0.5};this.v =  20;this.colorValue = "rgba("+this.color.r+","+this.color.g+","+this.color.b+","+this.color.a+")";this.angle = 0;this.timePlay = null;  },  changeColor : function(){  //颜色变换模式1  this.color.r += this.v;  if(this.color.r > 255){  this.color.r = 0;  this.color.g += this.v;  }  if(this.color.g > 255){  this.color.r = 0;  this.color.g = 0;  this.color.b += this.v;  }  if(this.color.b > 255){  this.color.r = 0;  this.color.g = 0;  this.color.b = 0;  }  this.colorValue = "rgba("+this.color.r+","+this.color.g+","+this.color.b+","+this.color.a+")";  },  changeColor2 : function(){  //颜色变换模式2  if(Toy.isIn(this.color.r + this.v, -1, 255)){  this.color.r += this.v;  }else{  if(Toy.isIn(this.color.g + this.v, -1, 255)){  this.color.g += this.v;  }else{  if(Toy.isIn(this.color.b + this.v, -1, 255)){  this.color.b += this.v;  }else{  this.v = -this.v;  }  }  }  this.colorValue = "rgba("+this.color.r+","+this.color.g+","+this.color.b+","+this.color.a+")";  },createPad : function(isReset){if(!isReset){this.pad = document.createElement("canvas");}this.pad.width =  this.radius * 2;this.pad.height = this.radius * 2;this.ctx = this.pad.getContext('2d');this.ctx.lineJoin = 'round';this.ctx.lineCap = 'round';this.ctx.lineWidth=.5;this.ctx.strokeStyle = this.colorValue;this.ctx.fillStyle = this.colorValue;if(!isReset){var dialogs = $class("myDialog"),lastOne = dialogs[dialogs.length - 1],pos = [0,0],scrollT = document.body.scrollTop || document.documentElement.scrollTop;if(lastOne){var rect = lastOne.getBoundingClientRect();if (rect.right > document.documentElement.offsetWidth - lastOne.offsetWidth) {pos = [rect.bottom + 10 + scrollT, 0];}else{pos = [rect.top + scrollT, rect.right+ 10];}}this.myPad = Win.open({title : "Pad - " + Toy.t++,html : "",width : this.pad.width +10,height : this.pad.height + 35,onclose : this.stop}).position("leftTop").css("top:"+pos[0]+"px;left:"+ pos[1] +"px;");$class("dialog_Cont",this.myPad.dom)[0].appendChild(this.pad);}},draw : function(isFirst){this.ctx.save();if(this.options.showColor){this.changeColor2();this.ctx.strokeStyle = this.colorValue;this.ctx.fillStyle = this.colorValue;}//大圆this.ctx.translate(this.radius, this.radius);if(isFirst){this.ctx.beginPath();this.ctx.arc(0,0,this.options.R,0,Math.PI*2,true);this.ctx.closePath();this.ctx.stroke();}//小圆this.ctx.rotate(-this.angle);this.ctx.translate(this.options.R-this.options.r,0);if(this.options.showCricle || isFirst){this.ctx.beginPath();this.ctx.arc(0,0,this.options.r,0,Math.PI*2,true);this.ctx.closePath();this.ctx.stroke();}//线this.ctx.rotate(this.angle * this.options.R/this.options.r);if(this.options.showLine || isFirst){this.ctx.beginPath();this.ctx.moveTo(0,0);this.ctx.lineTo(this.options.l,0);this.ctx.stroke();}//小点if(this.options.showPoint || isFirst){this.ctx.translate(this.options.l,0);this.ctx.beginPath();this.ctx.arc(0,0,1,0,Math.PI*2,true);this.ctx.fill();}this.ctx.restore();this.angle += 0.2;return this;},move : function(){var that = this,count = 0,_s = function(){that.clear(count == 0).draw();count ++;that.timePlay = setTimeout(_s,50);if(that.options.count < count) {clearTimeout(that.timePlay)};}_s();return this;},stop : function(){clearTimeout(this.timePlay);return this;},clear : function(isInit){if(this.options.isRefresh || isInit){this.ctx.clearRect(0,0,this.radius * 2,this.radius * 2);this.ctx.font = '10px Helvetica';this.ctx.fillStyle = '#fff';this.ctx.fillText("R: "+this.options.R, this.radius * 2 - 35, this.radius * 2-24 );this.ctx.fillText("r : "+this.options.r, this.radius * 2 - 35, this.radius * 2 - 12);this.ctx.fillText("l : "+this.options.l, this.radius * 2 - 35, this.radius * 2 );}return this;},reset : function(options){this.setOptions(options);this.createPad(true);this.draw(true);return this;}}Toy.isIn = function(v,min,max){return (v > min && v < max)};Toy.t = new Date();function getOpt(){return {R : $id("bigRadius").value - 0 || 133,r : $id("smallRadius").value - 0 || 140,l : $id("lineLength").value - 0 || 123,showPoint: $id("showPoint").checked,showCricle: $id("showCricle").checked,showLine: $id("showLine").checked,isRefresh: $id("isRefresh").checked,showColor : $id("showColor").checked}}window.onload = function(){var opt = getOpt();var temp1 = new Toy(opt),temp2 = new Toy(opt).move(),temp3 = new Toy({R:103,r:40,l:50}).move(),temp4 = new Toy({R:113,r:140,l:123}).move();var inputs = $class("opt");for (var i = inputs.length - 1; i >= 0; i--) {inputs[i].onchange = function(){temp1.reset(getOpt());}};events.addEvent($id("runBtn"),'click', function(){new Toy(getOpt()).move();});}</script></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_0129edb2-0b68-40ba-823c-05255b250beb');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_0129edb2-0b68-40ba-823c-05255b250beb');" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不算难，就是几个相对运动。&lt;/p&gt;
&lt;p&gt;&lt;textarea class=&quot;runcode_text&quot; id=&quot;runcode_0129edb2-0b68-40ba-823c-05255b250beb&quot;&gt;&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="canvas" scheme="https://www.cssass.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>XMLHttpRequest Level 2的跨域功能</title>
    <link href="https://www.cssass.com/2012/12/03/XMLHttpRequest%20Level%202%E7%9A%84%E8%B7%A8%E5%9F%9F%E5%8A%9F%E8%83%BD/"/>
    <id>https://www.cssass.com/2012/12/03/XMLHttpRequest%20Level%202%E7%9A%84%E8%B7%A8%E5%9F%9F%E5%8A%9F%E8%83%BD/</id>
    <published>2012-12-03T02:39:06.000Z</published>
    <updated>2023-06-30T12:57:03.458Z</updated>
    
    <content type="html"><![CDATA[<p>XMLHttpRequest Level 2的功能已经大幅提升了，<br>参见：<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html">http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html</a></p><p>我们知道，受到浏览器”同域限制“制约，以前的xhr对象是无法完成跨域请求的，而现在只需在Server端做一个访问控制，Client端再用xhr对象请求就行了，一般情况下Client并不需要设置，当然还有些相关的方法属性可供使用的，比如setRequestHeader，withCredentials。<br>服务端设置参见： <a href="https://developer.mozilla.org/en-US/docs/Server-Side_Access_Control">https://developer.mozilla.org/en-US/docs/Server-Side_Access_Control</a></p><p>下面我们简单的做个demo<br>Server端代码(PHP)：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_ORIGIN&#x27;</span>] == <span class="string">&quot;http://www.cssass.com&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Access-Control-Allow-Origin: http://www.cssass.com&#x27;</span>);</span><br><span class="line">            <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Type: text/plain&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] == <span class="string">&quot;GET&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="variable">$arr</span> = <span class="keyword">array</span>( </span><br><span class="line">                    <span class="string">&#x27;id&#x27;</span> =&gt; <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;XMLHttpRequest Response&#x27;</span> </span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">echo</span> <span class="title function_ invoke__">json_encode</span>(<span class="variable">$arr</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>http响应头设置参见：<a href="https://developer.mozilla.org/en-US/docs/HTTP_access_control#The_HTTP_response_headers">https://developer.mozilla.org/en-US/docs/HTTP_access_control#The_HTTP_response_headers</a></p><p>Client端代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;XMLHttpRequest 2演示&lt;/title&gt;</span><br><span class="line">&lt;a href=&quot;javascript:;&quot; onclick=&quot;get_xhr2()&quot;&gt;获取数据!(xhr2)&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function get_xhr2()&#123;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&#x27;GET&#x27;, &#x27;http://www.hzmilo.com/me.php?r=/xhr2/send&#x27;); //POST也支持</span><br><span class="line">xhr.onload = function(e) &#123; //绑定onload</span><br><span class="line">  var data = JSON.parse(this.response); //json解析</span><br><span class="line">  alert(data.name);</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>正如你所知，ie下是不支持XMLHttpRequest Level 2的，不过ie8引入了自己的跨域对象XDomainRequest。(同时ie8下的xhr对象也引入了 timeou属性t和ontimeout方法）<br>所以我们做下兼容（不支持ie6，ie7）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;XMLHttpRequest 2演示&lt;/title&gt;</span><br><span class="line">&lt;a href=&quot;javascript:;&quot; onclick=&quot;get_xhr2()&quot;&gt;获取数据!(xhr2)&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function get_xhr2()&#123;</span><br><span class="line">var xr,xrName;</span><br><span class="line">if(window.XDomainRequest)&#123;</span><br><span class="line">xr = new XDomainRequest();</span><br><span class="line">xrName = &quot;XDomainRequest&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">xr = new XMLHttpRequest();</span><br><span class="line">xrName = &quot;XMLHttpRequest&quot;;</span><br><span class="line">&#125;</span><br><span class="line">xr.open(&#x27;GET&#x27;, &#x27;http://www.hzmilo.com/me.php?r=/xhr2/send/&amp;xr=&#x27;+xrName);</span><br><span class="line">xr.onload = function(e) &#123;</span><br><span class="line">  var data = JSON.parse(this.responseText); //json解析</span><br><span class="line">  alert(data.name);</span><br><span class="line">&#125;</span><br><span class="line">xr.send();</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>接下来，我们来了解下JSONP这种在同域限制的情况下实现跨域请求（GET）的实现过程。<br>原理其实就是：以script标签的形式在页面中放置一个请求地址，该请求地址返回的数据格式为：</p><p>jsonp1354513528560({“id”:”2″,”name”:”JSON with Padding”})</p><p>如果jsonp1354513528560是一个预先定义好的JS方法，那么获取其参数（我们实际需要获取的数据）就顺理成章了。</p><p>以下是Client端的实现代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">        //jsonp的具体实现</span><br><span class="line">          var randomNum = (new Date).getTime(),</span><br><span class="line">              callName = null,</span><br><span class="line">              sendScriptRequest = function(url,id)&#123;</span><br><span class="line">                  //将请求地址以script标签形式插入到页面。（注定是GET请求）</span><br><span class="line">                var head = document.getElementsByTagName(&quot;head&quot;)[0];</span><br><span class="line">                var script = document.createElement(&quot;script&quot;);</span><br><span class="line">                script.id = id;</span><br><span class="line">                script.src = url;</span><br><span class="line">                script.charset = &#x27;utf-8&#x27;;</span><br><span class="line">                head.appendChild(script);</span><br><span class="line">            &#125;,</span><br><span class="line">            buildTempFunction = function(callback)&#123;</span><br><span class="line">                //创建一个全局方法，并将方法名当做请求地址的一个参数</span><br><span class="line">                callName = &quot;jsonp&quot; + randomNum++;</span><br><span class="line">                window[ callName ] = function(data)&#123;</span><br><span class="line">                    callback(data);</span><br><span class="line">                    window[ callName ] = undefined;</span><br><span class="line">                    try&#123; </span><br><span class="line">                        delete window[ callName ];</span><br><span class="line">                        //var jsNode = document.getElementById(callName);</span><br><span class="line">                        //jsNode.parentElement.removeChild(jsNode);  //执行全局方法后，将script标签删除</span><br><span class="line">                    &#125; catch(e)&#123;&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                return callName;</span><br><span class="line">            &#125;,</span><br><span class="line">            $jsonp = function(url,params)&#123;</span><br><span class="line">                //生成GET请求地址</span><br><span class="line">                  params.callback = buildTempFunction(params.callback);</span><br><span class="line">                  url += (url.indexOf(&quot;?&quot;)&gt;0 ) ? &quot;&quot; : &quot;?&quot; ;</span><br><span class="line">                  for(var i in params)</span><br><span class="line">                      url += &quot;&amp;&quot; + i + &quot;=&quot; + params[i];</span><br><span class="line">                sendScriptRequest(url,callName);</span><br><span class="line">              &#125;;</span><br><span class="line">            //对外开放接口：$jsonp</span><br><span class="line">            /**</span><br><span class="line">            * @$jsonp JSONP方法</span><br><span class="line">            * @param &#123;String&#125; url 请求地址</span><br><span class="line">            * @param &#123;Object&#125; params 请求参数</span><br><span class="line">            */ </span><br><span class="line">              if (!window.$jsonp)</span><br><span class="line">                   window.$jsonp = $jsonp;</span><br><span class="line">    &#125;)();</span><br></pre></td></tr></table></figure><p>Server端很简单,只需拼接输出一个js的执行方法即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$jsonp = $_GET[&#x27;callback&#x27;]; //请求端传递的callback参数，作为输出的方法名</span><br><span class="line">        $arr = array( </span><br><span class="line">            &#x27;id&#x27; =&gt; &#x27;2&#x27;,</span><br><span class="line">            &#x27;name&#x27; =&gt; &#x27;JSON with Padding&#x27; </span><br><span class="line">        );</span><br><span class="line">        echo $jsonp, &#x27;(&#x27;, json_encode($arr), &#x27;)&#x27;;</span><br></pre></td></tr></table></figure><p>演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;jsonp演示&lt;/title&gt;</span><br><span class="line">&lt;script src=&quot;/public/js/extend.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;a href=&quot;javascript:;&quot; onclick=&quot;get_jsonp()&quot;&gt;获取数据!(jsonp)&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function get_jsonp()&#123;</span><br><span class="line">$jsonp(&#x27;http://www.hzmilo.com/me.php?r=/xhr2/send2&#x27;,&#123;&quot;id&quot;:1001&#125;,function(data)&#123;</span><br><span class="line">alert(data.name);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>因为大多数网站不会开启server端的访问控制，所以xhr2目前比较适用于自己所属的几个域名下网站的连结,并且放弃ie6、7。<br>JSONP应用倒是很普遍，很多网站开放API的时候，也会用jsonp的形式给js提供接口，这样一来，使得ajax也能直接调用到API，当然只限一些普通的无需授权即用的接口。</p><p>然而很多网站并未开放API, 也未在服务端设置callback之类的参数，而我们也不想自己写server端代码去抓取。<br>那么我们可以试试中间代理：<a href="http://developer.yahoo.com/yql/">http://developer.yahoo.com/yql/</a></p><p>演示：我们抓取一下我很喜欢的一个电影网站（dianying.fm）的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;yql演示&lt;/title&gt;</span><br><span class="line">&lt;script src=&quot;/public/js/extend.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;a href=&quot;javascript:;&quot; onclick=&quot;get_yql()&quot;&gt;获取数据!(jsonp代理)&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function get_yql()&#123;</span><br><span class="line">$jsonp(&#x27;http://query.yahooapis.com/v1/public/yql&#x27;,&#123;</span><br><span class="line">q: &quot;select * from json where url=\&quot;http://dianying.fm/reflect/cannes/e30=/2\&quot;&quot;,</span><br><span class="line">    format: &quot;json&quot;&#125;,function(data)&#123;</span><br><span class="line">alert(data.query.results.json.html);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;XMLHttpRequest Level 2的功能已经大幅提升了，&lt;br&gt;参见：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html&quot;&gt;http://www.ruanyifen</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="ajax" scheme="https://www.cssass.com/tags/ajax/"/>
    
    <category term="jsonp" scheme="https://www.cssass.com/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>使用Three.js展现3D模型</title>
    <link href="https://www.cssass.com/2012/02/24/%E4%BD%BF%E7%94%A8Three-js%E5%B1%95%E7%8E%B03D%E6%A8%A1%E5%9E%8B/"/>
    <id>https://www.cssass.com/2012/02/24/%E4%BD%BF%E7%94%A8Three-js%E5%B1%95%E7%8E%B03D%E6%A8%A1%E5%9E%8B/</id>
    <published>2012-02-24T02:49:35.000Z</published>
    <updated>2023-07-01T05:55:42.485Z</updated>
    
    <content type="html"><![CDATA[<p>CSS3的3d-Transform，Canvas，SVG，WebGL等等技术的出现和发展，正将网页的3D化慢慢变得简单友好，但是3D建模毕竟有其很高的专业性，所以如果拥有一个内心强大，接口简洁的库就能使我们得心应手许多。Three.js便是备受推崇的一个，尽管API的变动，简陋的文档会让我们的上手比较困难。</p><p>下面我提供一个入门Demo，及一个用Three.js展示通用的3D模型格式的Demo。（注意：确保你使用的浏览器支持了Canvas，及WebGL。拥有一个先进的浏览器，将为你带来更好的上网体验。Test）</p><p>下面是入门Demo，加了注释。详细入门教程可以到这里Getting Started with Three.js</p><p><textarea class="runcode_text" id="runcode_62cbf37a-d093-406e-ab26-a75e75fd21de"><!DOCTYPE html><html><head><meta charset="UTF-8" /><title>立方体</title>    <script type="text/javascript" charset="utf-8" src="/public/js/three.min.js"></script><style>body{overflow:hidden;}</style></head><body></body><script>/* 场景 */var WIDTH = document.documentElement.offsetWidth || 800,HEIGHT = document.documentElement.clientHeight || 600;var scene = new THREE.Scene();/* 摄像头 */var VIEW_ANGLE = 75,ASPECT = WIDTH / HEIGHT,NEAR = 0.1,FAR = 10000;varcamera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR); /* 摄像机视角，视口长宽比，近切面，远切面 */camera.position.set(0, 0, 1000); //放置位置scene.add(camera);/* 显示对象 */var geometry = new THREE.CubeGeometry( 200, 200, 200 ), //几何属性。代码位于"\src\extras\geometries"material = new THREE.MeshLambertMaterial( { color: 0xcccccc} ); //材质属性 "\src\materials"var cube = new THREE.Mesh(geometry, material);cube.rotation.set(10,20,10); //放置角度scene.add(cube);/* 灯光 */var light = new THREE.DirectionalLight(0xFFFFFF); //直线光,"\src\lights"light.position.set(0, 0, 100).normalize();scene.add(light);/* 渲染器 */varrenderer = new THREE.CanvasRenderer(); //有Canvas，WebGL，SVG三种模式renderer.setSize(WIDTH , HEIGHT);document.body.appendChild(renderer.domElement);/* 动画 */(function anime(){cube.rotation.x += 0.01; //改变立方体角度renderer.render(scene, camera); //开始渲染return requestAnimationFrame(anime);})()</script></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_62cbf37a-d093-406e-ab26-a75e75fd21de');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_62cbf37a-d093-406e-ab26-a75e75fd21de');" /></p><p>考虑到Opera还不支持WebGL，上面使用了Canvas模式渲染。但WebGL的渲染模式要比Canvas快的要多的多。</p><p>下面是一个展示机器人MGA-411 Mangusa模型的Demo。<br>Three.js可以调用以Json格式存储模型信息的js文件来创建模型。模型你可以自己在3D软件上建模完成，或在网上下载。至于模型格式，你可以通过three.js提供的插件在Blender这款开源3D制作软件中将一些3D模型格式，如3ds，obj等，转换成符合three.js标准的js格式。</p><p><textarea class="runcode_text" id="runcode_e93bde8e-fc5d-4831-ac4e-b1f46c13d07a"><!DOCTYPE html><html><head><meta charset="UTF-8" /><title>MGA-411 Mangusa</title>    <script type="text/javascript" charset="utf-8" src="/blog/resource/threejs/three.min.js"></script><style>body{overflow:hidden;background:#000}</style></head><body><div id="Loading" style="color:#fff">Loading...</div></body><script>/* 场景 */var WIDTH = document.documentElement.offsetWidth || 800,HEIGHT = document.documentElement.clientHeight || 600;var scene = new THREE.Scene();/* 摄像头 */var VIEW_ANGLE = 75,ASPECT = WIDTH / HEIGHT,NEAR = 0.1,FAR = 10000;varcamera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);camera.position.set(0, 0, 1000);scene.add(camera);/* 渲染器 */varrenderer = new THREE.WebGLRenderer();renderer.setSize(WIDTH , HEIGHT);document.body.appendChild(renderer.domElement);/* 灯光 */var light = new THREE.DirectionalLight(0xFFFFFF);light.position.set(0, 0, 99).normalize();scene.add(light);/* 显示对象 */var material = new THREE.MeshLambertMaterial({ color: 0xcccccc, wireframe: true }),obj;var loader = new THREE.JSONLoader(true);    loader.load("/blog/resource/threejs/model/MGA.js", function ( geometry ) {var loading = document.getElementById("Loading");loading.parentNode.removeChild(loading);obj = new THREE.Mesh(geometry, material);obj.position.set(0,1,990);scene.add(obj);var start = new Date().getTime(),delta;(function anime(){delta = new Date().getTime() - start;obj.rotation.y =   delta / 1000;renderer.render(scene, camera);return requestAnimationFrame(anime);})();});</script></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_e93bde8e-fc5d-4831-ac4e-b1f46c13d07a');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_e93bde8e-fc5d-4831-ac4e-b1f46c13d07a');" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CSS3的3d-Transform，Canvas，SVG，WebGL等等技术的出现和发展，正将网页的3D化慢慢变得简单友好，但是3D建模毕竟有其很高的专业性，所以如果拥有一个内心强大，接口简洁的库就能使我们得心应手许多。Three.js便是备受推崇的一个，尽管API的变动，</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="3D" scheme="https://www.cssass.com/tags/3D/"/>
    
    <category term="threejs" scheme="https://www.cssass.com/tags/threejs/"/>
    
  </entry>
  
  <entry>
    <title>CSS3——体验Firefox10的3D Transform</title>
    <link href="https://www.cssass.com/2012/02/01/CSS3%E2%80%94%E2%80%94%E4%BD%93%E9%AA%8CFirefox10%E7%9A%843D%20Transform/"/>
    <id>https://www.cssass.com/2012/02/01/CSS3%E2%80%94%E2%80%94%E4%BD%93%E9%AA%8CFirefox10%E7%9A%843D%20Transform/</id>
    <published>2012-02-01T02:31:30.000Z</published>
    <updated>2023-06-30T07:53:43.392Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了一篇CSS3的崛起——体验webkit的3D-Effect。<br>随着firefox10正式版发布，firefox也支持3D Transform了，所以补充一篇，将上篇中的代码移植过来，支持firefox。</p><p>这里先穿插介绍下firefox10的新特性，firefox10除了支持3D Transform，还提供了Fullscreen API，令人兴奋吧。另外firefox10成为Mozila首个“长期支持版本”(Extended Support Release，简称“ESR”)，这种当然是市场考虑啦，至于是什么用意和市场反响我们就不探讨了。</p><p>下面是演示demo，只支持firefox10。 chrome浏览器的用户可以参考上一篇。</p><p><textarea class="runcode_text" id="runcode_3013e06e-aba7-47e6-bd86-e36f71ca37a2"><!DOCTYPE html><html><head><meta charset="utf-8" /><title>firefox10</title><style>*{padding:0;margin:0;}body { background-color:#deddcd;}#movieposters { list-style:none; margin:100px;}#movieposters li {float:left;-moz-perspective: 500px;}/* 图片3d变换效果 */#movieposters li img { border:10px solid #fcfafa;-moz-box-shadow:0 3px 10px #888;-moz-transform: rotateY(30deg);-moz-transition-property: -moz-transform;-moz-transition-duration: 0.5s;}#movieposters li:hover img {-moz-transform: rotateY(0deg); }/* 文字框3d变换效果 */.movieinfo {border:10px solid #fcfafa; padding:0 10px; width:120px; height:100px; background-color:#deddcd; margin:-125px 0 0 55px; position:absolute;-moz-box-shadow:0 10px 20px #888;-moz-transform: translateZ(30px) rotateY(30deg);-moz-transition-property: -moz-transform, box-shadow, margin;-moz-transition-duration: 0.5s; }#movieposters li:hover .movieinfo {-moz-box-shadow:0 5px 10px #888; margin:-105px 0 0 30px;-moz-transform: rotateY(0deg); }.movieinfo h3 {color:#7a3f3a;font-family:Georgia; text-align:center; }.movieinfo p {padding:10px 0;}.movieinfo a { display:block; background:#7a3f3a; padding:3px 0; color:#eee; text-decoration:none; text-align:center; margin:0 auto;-moz-border-radius:5px; }.movieinfo a:hover, .movieinfo a:focus { background-color:#6a191f; color:#fff; }</style></head><body><ul id="movieposters"><li><img src='http://www.cssass.com/blog/resource/avatar/avatar_m.jpg' width='200' /><div class="movieinfo"><h3>Avatar 2</h3><p>You like a baby</p><a href="http://www.cssass.com" title="I see you">More info</a></div></li><li><img src='http://www.cssass.com/blog/resource/avatar/avatar_m.jpg' width='200' /><div class="movieinfo"><h3>Avatar 2</h3><p>You like a baby</p><a href="http://www.cssass.com" title="I see you">More info</a></div></li><li><img src='http://www.cssass.com/blog/resource/avatar/avatar_m.jpg' width='200' /><div class="movieinfo"><h3>Avatar 2</h3><p>You like a baby</p><a href="http://www.cssass.com" title="I see you">More info</a></div></li></ul></body></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_3013e06e-aba7-47e6-bd86-e36f71ca37a2');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_3013e06e-aba7-47e6-bd86-e36f71ca37a2');" /></p><p>去除一些效果</p><p><textarea class="runcode_text" id="runcode_945b15ae-8007-4ae8-ab26-2e1bd1732495"><!DOCTYPE html><html><head><meta charset="utf-8" /><title>firefox10</title><style>*{padding:0;margin:0;list-style:none; }body { background:#deddcd;margin:100px;}#movieposters li {float:left;-moz-perspective: 500px;}#movieposters li img {-moz-transform: rotateY(30deg);-moz-transition-property: -moz-transform;-moz-transition-duration: 0.5s;}#movieposters li:hover img {-moz-transform: rotateY(0deg);}.movieinfo {position:absolute; width:120px; height:100px; background:#fff; margin:-125px 0 0 55px;-moz-transform: translateZ(30px) rotateY(30deg);-moz-transition-property: -moz-transform, margin;-moz-transition-duration: 0.5s;}#movieposters li:hover .movieinfo {margin:-105px 0 0 40px;-moz-transform: rotateY(0deg);}</style></head><body><ul id="movieposters"><li><img src='http://www.cssass.com/blog/resource/avatar/avatar_m.jpg' width='200' /><div class="movieinfo">(未设置transform-style，默认为plat)</div></li></ul></body></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_945b15ae-8007-4ae8-ab26-2e1bd1732495');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_945b15ae-8007-4ae8-ab26-2e1bd1732495');" /></p><p>使用preserve-3d，实现全方位3D</p><p><textarea class="runcode_text" id="runcode_5f24a886-9e71-42f9-b77d-d45cde2508d5"><!DOCTYPE html><html><head><meta charset="utf-8" /><title>firefox10</title><style>*{padding:0;margin:0;list-style:none; }body { background:#deddcd;margin:100px;}#movieposters{-moz-perspective: 1000px;}#movieposters li {float:left;-moz-animation: spin 10s infinite linear;}#movieposters li.first{-moz-transform-style: preserve-3d;}#movieposters li.second{-moz-transform-style: plat;} @-moz-keyframes spin {      from { -moz-transform: rotateY(0); }      to   { -moz-transform: rotateY(360deg); }    }#movieposters li img {-moz-transform: rotateY(30deg);-moz-transition-property: -moz-transform;-moz-transition-duration: 0.5s;}#movieposters li:hover img {-moz-transform: rotateY(0deg);}.movieinfo {position:absolute; width:120px; height:100px; background:#fff; margin:-125px 0 0 55px;-moz-transform: translateZ(30px) rotateY(30deg);-moz-transition-property: -moz-transform, margin;-moz-transition-duration: 0.5s;}#movieposters li:hover .movieinfo {margin:-105px 0 0 40px;-moz-transform: rotateY(0deg);}</style></head><body><ul id="movieposters"><li class='first'><img src='http://www.cssass.com/blog/resource/avatar/avatar_m.jpg' width='200' /><div class="movieinfo">Avatar 2 (preserve-3d)</div></li><li class='second'><img src='http://www.cssass.com/blog/resource/avatar/avatar_m.jpg' width='200' /><div class="movieinfo">Avatar 2 (plat)</div></li></ul></body></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_5f24a886-9e71-42f9-b77d-d45cde2508d5');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_5f24a886-9e71-42f9-b77d-d45cde2508d5');" /></p><p>最后说明一下firefox和webkit间使用的一点差别：<br>火狐10下的3D Transforms在设置perspective属性值时必须带单位px，webkit可以省略；<br>另外，webkit在用transition-property设置transform这个值时，可以不用前缀，而firefox需要写上-moz-transform;</p><p>现在综合Webkit和Firefox，写一个效果，顺便也兼用下另两个属性：transition 和 animation</p><p><textarea class="runcode_text" id="runcode_92c983b2-7fe4-4001-9667-39b77c82667f"><!doctype html><link href='http://fonts.googleapis.com/css?family=Ultra&v2' rel='stylesheet' type='text/css'><style>body{background:#333;}h1{font:normal 90px/1.5 'Ultra','Curlz MT','Bauhaus 93','Blackoak Std',Courier,Arial;color:#7e9409;position:absolute;top:85px;left:10px;width:300px;/* animation */-moz-animation: 1s slidein;-webkit-animation: 1s slidein;/* 3d-transform */-webkit-perspective: 600;-moz-perspective: 600px;}@-moz-keyframes slidein {from {top:1550px;}85% {top:5px;}to {top:85px;}}@-webkit-keyframes slidein {from {top:1550px;}85% {top:5px;}to {top:85px;}}.myLogo,.myLogo a{/*  transition */-moz-transition: all 2s ease-in-out 0s;-webkit-transition:all 2s ease-in-out 0;transition:all 2s ease-in-out 0;}.myLogo{position:relative;display:inline-block;zoom:1;top:0;left:0;text-shadow:-2px -1px 1px #7e9409;opacity: 0.8;filter:alpha(opacity=50);-webkit-transform: rotateY(30deg);-moz-transform: rotateY(30deg);transform: rotateY(30deg);}h1:hover .myLogo { /* 3d-transform */ -webkit-transform: rotateY(0);-moz-transform: rotateY(0);transform: rotateY(0);text-shadow:0;}.myLogo a{position:absolute;top:1px;left:5px;color:#B7D902;text-shadow:-1px -1px 1px #fff;text-decoration: none;}h1:hover .myLogo a{left: 2px;}</style><h1><span class="myLogo">CSSASS<a href="http://www.cssass.com/blog/">CSSASS</a></span></h1></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_92c983b2-7fe4-4001-9667-39b77c82667f');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_92c983b2-7fe4-4001-9667-39b77c82667f');" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前写了一篇CSS3的崛起——体验webkit的3D-Effect。&lt;br&gt;随着firefox10正式版发布，firefox也支持3D Transform了，所以补充一篇，将上篇中的代码移植过来，支持firefox。&lt;/p&gt;
&lt;p&gt;这里先穿插介绍下firefox10的新特性</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="CSS3" scheme="https://www.cssass.com/tags/CSS3/"/>
    
    <category term="3D" scheme="https://www.cssass.com/tags/3D/"/>
    
    <category term="Transform" scheme="https://www.cssass.com/tags/Transform/"/>
    
  </entry>
  
  <entry>
    <title>canvas的像素级操作——4.关注性能</title>
    <link href="https://www.cssass.com/2012/01/17/canvas%E7%9A%84%E5%83%8F%E7%B4%A0%E7%BA%A7%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%944-%E5%85%B3%E6%B3%A8%E6%80%A7%E8%83%BD/"/>
    <id>https://www.cssass.com/2012/01/17/canvas%E7%9A%84%E5%83%8F%E7%B4%A0%E7%BA%A7%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%944-%E5%85%B3%E6%B3%A8%E6%80%A7%E8%83%BD/</id>
    <published>2012-01-17T02:29:03.000Z</published>
    <updated>2023-06-30T07:53:50.659Z</updated>
    
    <content type="html"><![CDATA[<p>我们开篇就提过，canvas的像素级操作相对来说是很低效的。</p><p>我们试着写一个图片切割效果。</p><p><textarea class="runcode_text" id="runcode_f530ce1d-1874-4bd3-bc44-e53b78b53a65"><!DOCTYPE html><html><head><meta charset="utf-8"><title>效率相关</title></head><body><canvas id="board" width="100" height="110"></canvas><script type="text/javascript">function splinter(ctx,imgPixels){var round = 0; //统计循环次数for(var y = 0; y < imgPixels.height; y++){for(var x = 0; x < imgPixels.width; x++){/* 虽然只调用了putImageData一个方法，但是操作的data非常多 */ctx.putImageData(imgPixels, x, y, x, y, 1 ,1); //后四个参数控制显示区域round ++ ;}}return round;}function demo(img){var w = img.width,h = img.height;var temp = document.createElement('canvas');temp.width = w;temp.height = h;var tempCtx = temp.getContext('2d');tempCtx.drawImage(img, 0, 0, w, h);var ctx = document.getElementById('board').getContext('2d');var imgPixels = tempCtx.getImageData(0, 0, w, h);return splinter(ctx,imgPixels);}(function(){var img = new Image();img.src = "/blog/resource/avatar/avatar_s.jpg";img.width = 50;img.height = 55;img.onload = function(){var d = new Date();var func = demo(img);alert("耗时：" + (new Date() - d) + "(ms)，\n共执行了" + func + "次的putImageData");}})()</script></body></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_f530ce1d-1874-4bd3-bc44-e53b78b53a65');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_f530ce1d-1874-4bd3-bc44-e53b78b53a65');" /></p><p>对于这个效果，因为我们并不需要操作图像的rgba数据，而只是把图像进行分割，所以利用putImageData的后四个可见区参数进行了设置就行了。<br>但是，这样做的性能却非常不理想。因为我们操作的ImageData数据实在太多了，循环执行了2750遍，相当于我们对整幅图像进行了2750次的像素级复制，而其实在可见区之外的ImageData数据并不是我们所需要的。</p><p>那么，我们在对源图getImageData的时候，可以只获取我们需要的ImageData。</p><p><textarea class="runcode_text" id="runcode_351ff46e-f8b2-4093-8ac2-abc468ede720"><!DOCTYPE html><html><head><meta charset="utf-8"><title>效率相关</title></head><body><canvas id="board" width="100" height="110"></canvas><script type="text/javascript">function splinter(ctx,tempCtx, w, h){var newData = [];var round = 0; //统计循环次数for(var y = 0; y < h; y++){newData[y] = [];for(var x = 0; x < w; x++){newData[y][x] = tempCtx.getImageData(x, y, 1, 1); //分开获取所需要的ImageDatactx.putImageData(newData[y][x], x*2, y*2);round ++ ;}}return round;}function demo(img){var w = img.width,h = img.height;var temp = document.createElement('canvas');temp.width = w;temp.height = h;var tempCtx = temp.getContext('2d');tempCtx.drawImage(img, 0, 0, w, h);var ctx =  document.getElementById('board').getContext('2d');return round = splinter(ctx,tempCtx, w, h);}(function(){var img = new Image();img.src = "/blog/resource/avatar/avatar_s.jpg";img.width = 50;img.height = 55;img.onload = function(){var d = new Date();var func = demo(img);alert("耗时：" + (new Date() - d) + "(ms)，\n共执行了" + func + "次的getImageData和putImageData");}})()</script></body></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_351ff46e-f8b2-4093-8ac2-abc468ede720');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_351ff46e-f8b2-4093-8ac2-abc468ede720');" /></p><p>第二种做法虽然在循环的时候多运行了一个方法（共执行2750次的getImageData和putImageData方法），但因为操作的ImageData少了2750倍，所以在效率上比第一种方式高了很多。</p><p>但从流程上来讲，我们只需要在刚开始的时候获取一次源图的ImageData（执行getImageData），对数据进行再排列后，最后再输出一次新的ImageData（执行putImageData）就可以了。<br>根本不需要在循环中反复调用getImageData和putImageData。所以现在的关键点是get和put之间的如何对数据进行重排列。</p><p>ImageData.data可以看做一个矩形矩阵，我们已知，它的序列号（n）与ImageData.width(w),及x轴序列号(x),y轴序列号（y）的关系是：n &#x3D; ((y * w) + x) * 4; （其中的4表示了RGBA四个数据）。我们要的新的输出ImageData，其实是x加倍，y加倍，w加倍的一个新矩阵。那么新矩阵序号与原x,y,w的关系式应该是：t &#x3D; ((y * 2 * w * 2) + x * 2) * 4;</p><p><textarea class="runcode_text" id="runcode_7c100920-a7be-4420-80aa-ec5ace268406"><!DOCTYPE html><html><head><meta charset="utf-8"><title>效率相关</title></head><body><canvas id="board" width="100" height="110"></canvas><script type="text/javascript">function splinter(ctx,imgPixels){var round = 0; //统计循环次数var n = 0,w = imgPixels.width,h = imgPixels.height,newdata = ctx.createImageData(w*2, h*2);for(var y = 0; y < h; y++){for(var x = 0; x < w; x++){n = ((y * w) + x) * 4; /* data序号n与x,y,w的关系 */t = ((y * 2 * w * 2) + x * 2) * 4; /* 分割后，y,x,w都变大了一倍 */newdata.data[t] =  imgPixels.data[n];newdata.data[t + 1] =  imgPixels.data[n + 1];newdata.data[t + 2] =  imgPixels.data[n + 2];newdata.data[t + 3] =  imgPixels.data[n + 3];round ++ ;}}ctx.putImageData(newdata, 0, 0);return round;}function demo(img){var w = img.width,h = img.height;var temp = document.createElement('canvas');temp.width = w;temp.height = h;var tempCtx = temp.getContext('2d');tempCtx.drawImage(img, 0, 0, w, h);var ctx = document.getElementById('board').getContext('2d');var imgPixels = tempCtx.getImageData(0, 0, w, h);return splinter(ctx,imgPixels);}(function(){var img = new Image();img.src = "/blog/resource/avatar/avatar_s.jpg";img.width = 50;img.height = 55;img.onload = function(){var d = new Date();var func = demo(img);alert("耗时：" + (new Date() - d) + "(ms)，\n共循环了" + func + "次,循环内不执行getImageData和putImageData方法");}})()</script></body></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_7c100920-a7be-4420-80aa-ec5ace268406');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_7c100920-a7be-4420-80aa-ec5ace268406');" /></p><p>第三种方法相对于第二种方法的效率提高了十几倍。第三种方法的关键点是找出新旧矩阵之间的关系，对于我们这一例来说还比较容易，复杂一点的，算法可就没这么简单了。</p><p>——————————————<br>重要补充：</p><p>我们先总结下三种方法：第一种：效率低差，但理解起来最简单。第三种，算法复杂，但效率最高。第二种，折中。<br>然而，如果使用的是webkit，opera浏览器，我们会发现第一种方法的效率比之第三种方法居然差不了多少！<br>可以看出webkit,opera对putImageData做过优化。对于putImageData(imgdata, x, y, x, y, 1 ,1)方法，webkit,opera只对（x,y,1,1）这个1平方px区域内的数据进行了put操作，区域外的数据并没有进行操作，这样在效率上会有很大的提高。<br>可惜的是firefox(9)就没有做过优化。要加油啊，Mozila！<br>最新测试了下ie9，结果显示第一种方法的效率的确很低，而第二种方法比第一种方法的效率还要低一倍。看来ie9果然也没用对putImageData进行优化，而且ie9下的getImageData也没用像其他浏览器下那么优化。对于getImageData(x,y,1,1)的获取，它操作的整个图像的像素数据的，而不是那个1平方px内的数据。</p><p>目前来说，考虑到各个浏览器原生方法的效率问题，第三种方法是最优的，即不要反复调用getImageData和putmageData，因为某些浏览器下一旦调用就是操作全部imageData的，而不会看你的参数。不过在未来，各个浏览器肯定会对原生方法进行优化的，在考虑第一种方法的时候就不用有所顾忌了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们开篇就提过，canvas的像素级操作相对来说是很低效的。&lt;/p&gt;
&lt;p&gt;我们试着写一个图片切割效果。&lt;/p&gt;
&lt;p&gt;&lt;textarea class=&quot;runcode_text&quot; id=&quot;runcode_f530ce1d-1874-4bd3-bc44-e53b78b53a</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="canvas" scheme="https://www.cssass.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas的像素级操作——3.使用卷积矩阵</title>
    <link href="https://www.cssass.com/2012/01/12/canvas%E7%9A%84%E5%83%8F%E7%B4%A0%E7%BA%A7%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%943-%E4%BD%BF%E7%94%A8%E5%8D%B7%E7%A7%AF%E7%9F%A9%E9%98%B5/"/>
    <id>https://www.cssass.com/2012/01/12/canvas%E7%9A%84%E5%83%8F%E7%B4%A0%E7%BA%A7%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%943-%E4%BD%BF%E7%94%A8%E5%8D%B7%E7%A7%AF%E7%9F%A9%E9%98%B5/</id>
    <published>2012-01-12T02:25:48.000Z</published>
    <updated>2023-06-30T07:53:53.684Z</updated>
    
    <content type="html"><![CDATA[<p>利用卷积矩阵(Convolution Matrix)操作像素，我们可以很方便的得到诸如模糊、边缘检测、锐化、浮雕和斜角这样的效果。</p><p>常用的矩阵类型是 3 x 3 矩阵，另外还有5 x 5的矩阵。</p><p>工作原理：<a href="http://flex4jiaocheng.com/blog/280">http://flex4jiaocheng.com/blog/280</a></p><p>点阵图中的每一个像素被称为“初步像素”，用与卷积矩阵同样面积的“初步像素”从左到右从上到下与卷积矩阵中相应位置的值相乘，再将得到的9个或25个中间值相加，就得到了“初步像素”矩阵中央的一个值的结果值再与Divisor（因子）相除，与Offset（偏移量）相加，最后得到终值。如下图所示：</p><p>应用卷积矩阵实现特效:</p><p><textarea class="runcode_text" id="runcode_b8c9f489-0af2-4da6-b5ac-1303881d9860"><!DOCTYPE html><html><head><meta charset="utf-8"><title>利用卷积矩阵实现特效</title></head><body><canvas id="canvas1" width="200" height="200" title="浮雕效果"></canvas><canvas id="canvas2" width="200" height="200" title="边缘检测"></canvas><canvas id="canvas3" width="200" height="200" title="锐化"></canvas><canvas id="canvas4" width="200" height="200" title="基本模糊"></canvas><canvas id="canvas5" width="200" height="200" ></canvas><script type="text/javascript">function convolution(imgPixels, matrix, divisor, offset){/* 卷积矩阵应用函数 */    var w = imgPixels.width,h = imgPixels.height,d = imgPixels.data;var canvas = document.createElement('canvas'),ctx = canvas.getContext('2d'),newImgPixels = ctx.createImageData(w,h);for (var y = 1; y < h-1; y++) {for (var x = 1; x < w-1; x++) {for (var c = 0; c < 3; c++) {/* RGB通道 */var i = (y*w + x)*4 + c;newImgPixels.data[i]=(matrix[0]*d[i-(w+1)*4] + matrix[1]*d[i-w*4] + matrix[2]*d[i-(w-1)*4]+ matrix[3]*d[i-4]       + matrix[4]*d[i]     + matrix[5]*d[i+4]+ matrix[6]*d[i+(w-1)*4] + matrix[7]*d[i+w*4] + matrix[8]*d[i+(w+1)*4])/ divisor + offset;}newImgPixels.data[(y*w + x)*4 + 3] = 255;}}    return newImgPixels;}(function(){/* demo */var imgObj = new Image();imgObj.src = '/blog/resource/avatar/avatar_s.jpg';var embossing = {/* 浮雕效果 */matrix : [-2, -1, 0,  -1,  1, 1,   0,  1, 2],divisor: 1,offset : 0},edge = {/* 边缘检测 */matrix : [0, -1, 0, -1,  4, -1,  0, -1, 0],divisor: 1,offset : 0},sharpening = {/* 锐化 */matrix : [ 0, -1, 0,  -1,  5, -1,  0,  -1, 0],divisor: 1,offset : 0},blur = {/* 基本模糊 */matrix : [0, 1, 0,  1, 1, 1,  0, 1, 0],divisor: 5,offset : 0},oneboys = {/* 胡诌的一个矩阵 */matrix : [ 0, 1, 4,  -1,  5, -1,  3,  -1, 2],divisor: 5,offset : 0};function process(obj,effect){var context = document.getElementById(obj).getContext('2d');context.drawImage(imgObj, 0, 0);var imgPixels = context.getImageData(0, 0, imgObj.width, imgObj.height);imgPixels = convolution(imgPixels, effect.matrix, effect.divisor, effect.offset)context.putImageData(imgPixels, 0, 0, 0, 0, imgPixels.width, imgPixels.height);}var canvas = document.getElementsByTagName('canvas');for(var i = 0, l = canvas.length; i < l; i++ ){var loadObj = new Load(canvas[i]);(function(obj){obj.loading();imgObj.addEventListener('load',obj.loaded,false);})(loadObj);};imgObj.addEventListener('load',function(){process('canvas1',embossing);process('canvas2',edge);process('canvas3',sharpening);process('canvas4',blur);process('canvas5',oneboys);},false);})()/* 以下与示例代码无关 */function Load(canvas){/* canvas Loading 效果 */var backCtx = canvas.getContext('2d');backWidth = canvas.width;backHeight = canvas.height;var drawIntervalID,spokes = 7;vardrawPad = document.createElement('canvas');drawPad.width = 30;drawPad.height = 30;vardrawCtx = drawPad.getContext('2d');drawCtx.translate(drawPad.width/2, drawPad.height/2);drawCtx.lineWidth = 5;drawCtx.lineCap = "round";drawCtx.strokeStyle = "rgba(0,0,0,0.1)";drawCtx.fillStyle = "#fff";var draw = function(){drawCtx.fillRect(0,0, drawPad.width ,drawPad.height);drawCtx.rotate(Math.PI*2/spokes);for (var i=0; i<spokes; i++) {drawCtx.rotate(Math.PI*2/spokes);drawCtx.beginPath();drawCtx.moveTo(0,8);drawCtx.lineTo(0,10);drawCtx.stroke();}backCtx.drawImage(drawPad,(backWidth - drawPad.width)/2, (backHeight - drawPad.height)/2);}this.loading = function(){ drawIntervalID = setInterval(draw,200);}this.loaded = function(){clearInterval(drawIntervalID);backCtx.clearRect((backWidth - drawPad.width)/2, (backHeight - drawPad.height)/2, drawPad.width ,drawPad.height);}}</script></body></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_b8c9f489-0af2-4da6-b5ac-1303881d9860');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_b8c9f489-0af2-4da6-b5ac-1303881d9860');" /></p><p>上面demo中卷积的实现函数来自于在HTML 5 的 Canvas 中应用卷积矩阵对图像处理</p><p>推荐一篇有趣的文章：卷积的物理意义</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;利用卷积矩阵(Convolution Matrix)操作像素，我们可以很方便的得到诸如模糊、边缘检测、锐化、浮雕和斜角这样的效果。&lt;/p&gt;
&lt;p&gt;常用的矩阵类型是 3 x 3 矩阵，另外还有5 x 5的矩阵。&lt;/p&gt;
&lt;p&gt;工作原理：&lt;a href=&quot;http://flex</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="canvas" scheme="https://www.cssass.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas的像素级操作——1.引子</title>
    <link href="https://www.cssass.com/2012/01/06/canvas%E7%9A%84%E5%83%8F%E7%B4%A0%E7%BA%A7%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%941-%E5%BC%95%E5%AD%90/"/>
    <id>https://www.cssass.com/2012/01/06/canvas%E7%9A%84%E5%83%8F%E7%B4%A0%E7%BA%A7%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%941-%E5%BC%95%E5%AD%90/</id>
    <published>2012-01-06T02:16:32.000Z</published>
    <updated>2023-06-30T07:53:57.187Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对《MDC的canvas经典教程辑和个人学习笔记》的补遗，也是canvas像素级操作系列文章的一个引子。</p><p>既然是引子，那就不能开门见山的介绍了，我们先讲讲如何复制canvas.<br>已知一个image对象，我们将其绘制进canvas的方法是什么？drawImage。（当然使用createPattern模板填充也是一个方法）。<br>那已知一个canvas对象，我们将其绘制进另一个canvas的方法呢？<br>答案还是drawImage，drawImage算是一个很辽阔的方法了，不仅可以绘image，也可以绘canvas对象，甚至还可以绘video的帧。</p><p>并且他拥有大量参数：(Image [, vXSrc] [, vYSrc] [, vWSrc] [, vHSrc], vXDest, vYDest [, vWDest] [, vHDest])，这个读者可以先不管，往下看。</p><p>那么，除了drawImage这个方法，还有没有其他方法呢——有，putImageData方法隆重登场。</p><p><textarea class="runcode_text" id="runcode_dd862efe-a6ad-4094-ae0c-053ab23b51b5"><!DOCTYPE html><html><head><title>canvas绘制与复制及像素级复制</title></head><body><p>原图：imgObj<br /><img id="imgObj" src="/blog/resource/avatar/avatar_s.jpg" width="200" /><p>canvas中绘制的图：MyCanvas<br /><canvas id="MyCanvas" width="200" height="220" > </canvas><p>从MyCanvas复制过来的图：YourCanvas<br /><canvas id="YourCanvas" width="200" height="220"> </canvas><p>从MyCanvas的ImageData复制来的图：GodCanvas （注意，这里只是为了引出canvas的像素级操作，通常像素级操作是很低效的）<br /><canvas id="GodCanvas" width="200" height="220"> </canvas></body></html><script type="text/javascript">function draw(){/* 在canvas中绘制image */var canvas1 = document.getElementById("MyCanvas");var ctx1 = canvas1.getContext("2d");ctx1.drawImage(imgObj,0,0);}function clone(){/* 在canvas2中绘制canvas1 ——普通复制 */var origin = document.getElementById("MyCanvas");var canvas2 = document.getElementById("YourCanvas");var ctx2 = canvas2.getContext("2d");ctx2.drawImage(origin,0,0); //drawImage不仅可以绘image，也可以绘canvas对象，甚至还可以绘video的帧}function cloneData(canvasObj){/* 获取canvas1中的ImageData，在canvas3中输出 ——像素级复制 */var origin = document.getElementById("MyCanvas");var canvas3 = document.getElementById("GodCanvas");var ctx3 = canvas3.getContext("2d");var canvasCtx = origin.getContext("2d");var imagePix = canvasCtx.getImageData(0,0,origin.width,origin.height); // 获取canvas1绘图环境下的参数范围内的imageData。ctx3.putImageData(imagePix,0,0);    //putImageData输出图像}/* 以下与示例代码无关 */function Load(canvas){/* canvas Loading 效果 */var backCtx = canvas.getContext('2d');backWidth = canvas.width;backHeight = canvas.height;var drawIntervalID,spokes = 7;vardrawPad = document.createElement('canvas');drawPad.width = 30;drawPad.height = 30;vardrawCtx = drawPad.getContext('2d');drawCtx.translate(drawPad.width/2, drawPad.height/2);drawCtx.lineWidth = 5;drawCtx.lineCap = "round";drawCtx.strokeStyle = "rgba(0,0,0,0.1)";drawCtx.fillStyle = "#fff";var draw = function(){drawCtx.fillRect(0,0, drawPad.width ,drawPad.height);drawCtx.rotate(Math.PI*2/spokes);for (var i=0; i<spokes; i++) {drawCtx.rotate(Math.PI*2/spokes);drawCtx.beginPath();drawCtx.moveTo(0,8);drawCtx.lineTo(0,10);drawCtx.stroke();}backCtx.drawImage(drawPad,(backWidth - drawPad.width)/2, (backHeight - drawPad.height)/2);}this.loading = function(){ drawIntervalID = setInterval(draw,200);}this.loaded = function(){clearInterval(drawIntervalID);backCtx.clearRect((backWidth - drawPad.width)/2, (backHeight - drawPad.height)/2, drawPad.width ,drawPad.height);}}var imgObj = document.getElementById("imgObj");var canvas = document.getElementsByTagName('canvas');for(var i = 0, l = canvas.length; i < l; i++ ){var loadObj = new Load(canvas[i]);(function(obj){obj.loading();imgObj.addEventListener('load',obj.loaded,false);})(loadObj);}imgObj.addEventListener('load',function(){draw();clone();cloneData();},false);</script></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_dd862efe-a6ad-4094-ae0c-053ab23b51b5');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_dd862efe-a6ad-4094-ae0c-053ab23b51b5');" /></p><p>上面的cloneData方法就是通过将源canvas中像素数据ImageData，输出(putImageData)到新的canvas中，达到复制作用。</p><p>不过，我们在获取和输出ImageData的过程中，并没有对ImageData做过任何处理，而这个ImageData数据是包含{width,height,CanvasPixelArray},其中CanvasPixelArray包含了图像(canvas也可看做图像)的每一个像素的RGBA数据，可见中间的操作空间是很大的，以后我们会做重点讨论。</p><p>插注：CanvasPixelArray——在最新标准中已引入一个Uint8ClampedArray的Typed Array来替代 ，在各浏览器实现之后，将使得对ImageData的操作更快速更便捷。参考例子：<a href="http://hacks.mozilla.org/2011/12/faster-canvas-pixel-manipulation-with-typed-arrays/">http://hacks.mozilla.org/2011/12/faster-canvas-pixel-manipulation-with-typed-arrays/</a></p><p>下面介绍一下像素操作的三个方法：</p><p>createImageData();<br>getImageData();<br>putImageData();</p><p>createImageData的参数是(w,h)可以新建一个W*H尺寸的新的ImageData【firefox3.5开始支持】，不过也可以使用参数(anotherImageData)来创建【firefox5开始支持】。</p><p>getImageData的参数（x,y,w,h）表示起点x,y,尺寸w,h。可以获取canvas.context中在参数范围内的ImageData。</p><p>putImageData的参数使用要着重要介绍下（和drawImage的参数可以触类旁通）：</p><p><textarea class="runcode_text" id="runcode_22e1fd86-3a98-4ebd-b974-48fd4a2370fe"><!DOCTYPE html><html><head><title>putImageData的参数</title><style>canvas{border:1px solid #ccc;}</style></head><body><canvas id="canvas1" width="300" height="300"></canvas><canvas id="canvas2" width="300" height="300"></canvas></body></html><script type="text/javascript">(function draw(){var canvas0 = document.createElement("canvas"),ctx = canvas0.getContext("2d");var canvas1 = document.getElementById("canvas1"),ctx1 = canvas1.getContext("2d");var canvas2 = document.getElementById("canvas2"),ctx2 = canvas2.getContext("2d");var img = new Image();img.src="/blog/resource/avatar/avatar_s.jpg";img.onload=function(){canvas0.width = img.width;canvas0.height = img.height;ctx.drawImage(img,0,0);var imagePix = ctx.getImageData(0,0,canvas0.width,canvas0.height);/* putImageData参数(ImageData, dx, dy [, DirtyX] [, DirtyX] [, DirtyWidth] [, DirtyHeight]) */ctx1.putImageData(imagePix,30,30);  //imageData（包含了width,height,还有一个CanvasPixelArray）；dx, dy表示绘图起始位置ctx2.putImageData(imagePix,0,0,100,100,50,50); //后面四个可选参数表示可见区范围。缺省为：0,0,ImageData.width,ImageData.height}})()</script></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_22e1fd86-3a98-4ebd-b974-48fd4a2370fe');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_22e1fd86-3a98-4ebd-b974-48fd4a2370fe');" /></p><p>putImageData参数有(ImageData, dx, dy [, DirtyX] [, DirtyX] [, DirtyWidth] [, DirtyHeight])</p><p>imageData：包含了图像的width,height,还有一个CanvasPixelArray，前面已经提了。<br>dx, dy：表示绘图起始位置。相对于canvas区域左上角。<br>后面四个可选参数：表示可见区范围。相对于起绘点，即上面的参数dx,dy表示的点。缺省为0,0,ImageData.width,ImageData.height。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是对《MDC的canvas经典教程辑和个人学习笔记》的补遗，也是canvas像素级操作系列文章的一个引子。&lt;/p&gt;
&lt;p&gt;既然是引子，那就不能开门见山的介绍了，我们先讲讲如何复制canvas.&lt;br&gt;已知一个image对象，我们将其绘制进canvas的方法是什么？dra</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="canvas" scheme="https://www.cssass.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>如何获取元素的尺寸和位置——两个冷门方法</title>
    <link href="https://www.cssass.com/2012/01/04/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%B0%BA%E5%AF%B8%E5%92%8C%E4%BD%8D%E7%BD%AE%E2%80%94%E2%80%94%E4%B8%A4%E4%B8%AA%E5%86%B7%E9%97%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://www.cssass.com/2012/01/04/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%B0%BA%E5%AF%B8%E5%92%8C%E4%BD%8D%E7%BD%AE%E2%80%94%E2%80%94%E4%B8%A4%E4%B8%AA%E5%86%B7%E9%97%A8%E6%96%B9%E6%B3%95/</id>
    <published>2012-01-04T02:13:56.000Z</published>
    <updated>2023-06-30T07:50:59.913Z</updated>
    
    <content type="html"><![CDATA[<p>获取元素的尺寸，似乎offsetWidth&#x2F;Height就可以了，还需要什么方法吗？<br>的确，一般情况下，获取元素尺寸，用offsetWidth&#x2F;Height就搞定了，但如果这个元素是display:none的呢？<br>试验一下就知道，none元素的尺寸是0。</p><p>所以需要我们下面的这个方法来获取。</p><p><textarea class="runcode_text" id="runcode_e12544bc-9acc-4261-8fd9-f0e486f38063"><!doctype html><html><head><meta charset="utf-8" /><title>获取display:none元素的size</title><style>body{color:#ccc;}</style></head><body><div id="box" style="width:100px;height:100px;padding:20px;border:10px solid #ccc;display:none;">asdd</div></body><script type="text/javascript">function $id(o){return document.getElementById(o);}var getSize = function(elem){if(elem.offsetWidth !== 0){/* 元素不是display:none的情况，这个时候是能得到尺寸的 */return {'width':elem.offsetWidth,'height':elem.offsetHeight};}var old = {};/* 将display:none元素设成visibility:hidden */var options = { position: "absolute", visibility: "hidden", display:"block" }for ( var name in options ) {old[ name ] = elem.style[ name ];elem.style[ name ] = options[ name ];}var temp = {'width':elem.offsetWidth,'height':elem.offsetHeight};for ( var name in options ) {elem.style[ name ] = old[ name ];}return temp;};alert(getSize($id("box")).height)</script></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_e12544bc-9acc-4261-8fd9-f0e486f38063');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_e12544bc-9acc-4261-8fd9-f0e486f38063');" /></p><p>第二个，获取元素的位置。<br>或许你经常使用offsetLeft&#x2F;Top来获取位置，不过offsetLeft&#x2F;Top是相对 offsetParent的位置（在ie6，7下是相对直接父级的),并且在firefox下还有些小bug</p><p>下面这个方法提供获取元素相对于窗口（页面可视区）的距离。</p><p><textarea class="runcode_text" id="runcode_5ed7da59-5fb9-4555-a6a5-1d6c3c001834"><!doctype html><html><head><meta charset="utf-8" /><title>元素相对窗口左上角的值（ie下没有width，height值）</title><style>*{padding:0;margin:0;}#box{position:absolute;left:200px;width:100px;height:200px;border:5px solid #ccc;background:#eee;}</style></head><body><div id="box"></div></body><script type="text/javascript">var box = document.getElementById("box");var pos = box.getBoundingClientRect();box.innerHTML = "top:"+pos.top +"<br />left:"+pos.left +"<br />bottom:"+pos.bottom +"<br />right:"+pos.right +"<br />width:"+pos.width +"<br />height:"+pos.height</script></html></textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_5ed7da59-5fb9-4555-a6a5-1d6c3c001834');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_5ed7da59-5fb9-4555-a6a5-1d6c3c001834');" /></p><p>这个方法是由ie提出的，不过在其他浏览器吸收之后，还加了width，height两个值。</p><p>重复一下，这个方法是相对于页面窗口的，至于相对于整个页面文档的距离，那只需加上scrollTop这些值就行了，不做赘述。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;获取元素的尺寸，似乎offsetWidth&amp;#x2F;Height就可以了，还需要什么方法吗？&lt;br&gt;的确，一般情况下，获取元素尺寸，用offsetWidth&amp;#x2F;Height就搞定了，但如果这个元素是display:none的呢？&lt;br&gt;试验一下就知道，none元素</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="DOM" scheme="https://www.cssass.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>mouseenter/mouseleave事件和delegate方法的实现</title>
    <link href="https://www.cssass.com/2011/12/18/mouseenter-mouseleave%E4%BA%8B%E4%BB%B6%E5%92%8Cdelegate%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.cssass.com/2011/12/18/mouseenter-mouseleave%E4%BA%8B%E4%BB%B6%E5%92%8Cdelegate%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2011-12-18T03:20:54.000Z</published>
    <updated>2023-07-01T08:16:27.267Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，事件onmouseover和onmouseout有一个极其不好的问题，就是在绑定元素内部的子元素上滑动会反复触发事件，及执行绑定的方法。</p><p>而ie在很早的时候有提供了另一对事件：mouseenter和mouseleaver。顾名思义，就是只有当mouse滑进滑出绑定元素的时候，才会触发。</p><p>但是，这本来只是ie的私有属性，虽然已属于DOM3 Event草案当中，其他浏览器的支持率并不是很高，目前看来，Opera11.10已提供支持，而Firefox到10.0会提供支持，Webkit的暂无消息。<br>所以，如果想要用，我们得自己动手。</p><p>先搞一个通用的事件绑定函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var addEvent = function( target,type,fn ) &#123;</span><br><span class="line">    if(target.addEventListener)</span><br><span class="line">    &#123;</span><br><span class="line">        target.addEventListener(type,fn,false);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(target.attachEvent)</span><br><span class="line">    &#123;</span><br><span class="line">        target.attachEvent(&quot;on&quot; + type,fn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var removeEvent = function(target,type,fn ) &#123;</span><br><span class="line">    if(target.addEventListener)</span><br><span class="line">    &#123;</span><br><span class="line">        target.removeEventListener(type,fn,false);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(target.attachEvent)</span><br><span class="line">    &#123;</span><br><span class="line">        target.detachEvent(&quot;on&quot; + type,fn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们的mouseenter&#x2F;leave是通过mouseover&#x2F;out来实现的，只需屏蔽mouseover&#x2F;out在元素内部触发时的事件传播即可。<br> <p><textarea class="runcode_text" id="runcode_7cbdae66-246c-48ad-b5a0-bbdcd49e5607"><!DOCTYPE html><html><head><meta charset="utf-8" /><title>实现mouseenter、mouseleave事件</title><style>.outer{padding:50px;background:#aaa;}.inner{height:100px;background:#eee;}</style></head><body><div id="outer" class="outer">只有移进移出外框的时候才执行方法。对内框操作不执行。click点击解除绑定。<div id="inner" class="inner"></div></div></body><script>var $id=function(o){return document.getElementById(o) || o;}var events = {}events._mouseFn ={}; //保存“onmouseenter”和“onmouseleave”所绑定的方法events._mouseHandle = function(fn){/* 转换方法，符合条件时才会执行 */var func = function(event){var target = event.target;var parent = event.relatedTarget; //在onmouseover/out操作中，相关的另一个节点while( parent && parent != this ){try{ parent = parent.parentNode; }catch(e){break;}}/* 只有当相关节点的父级不会是绑定的节点时（即二者不是父子的包含关系），才调用fn，否则不做处理 */( parent != this ) && (fn.call(target,event));};return func;}events.addEvent = function( obj,type,fn ) {if(obj.addEventListener)    {if(obj.onmouseenter !== undefined){//for opera11，firefox10。他们也支持“onmouseenter”和“onmouseleave”，可以直接绑定obj.addEventListener(type,fn,false);return ;}if(type=="mouseenter" || type=="mouseleave" ){var eType = (type=="mouseenter") ? "mouseover" : "mouseout";var fnNew = events._mouseHandle(fn);obj.addEventListener(eType,fnNew,false); /* 将方法存入events._mouseFn，以便以后remove */if(!events._mouseFn[obj]) events._mouseFn[obj] = {};if(!events._mouseFn[obj][eType]) events._mouseFn[obj][eType] = {};events._mouseFn[obj][eType][fn] = fnNew;}else{obj.addEventListener(type,fn,false);}    }else if(obj.attachEvent)    {// for ie        obj.attachEvent("on" + type,fn);    }};events.removeEvent = function(obj,type,fn ) {    if(obj.addEventListener)    {if(obj.onmouseenter !== undefined){obj.removeEventListener(type,fn,false);return ;}if(type=="mouseenter" || type=="mouseleave" ){var eType = (type=="mouseenter") ? "mouseover" : "mouseout";if(!events._mouseFn[obj][eType][fn]) return;obj.removeEventListener(eType,events._mouseFn[obj][eType][fn],false);events._mouseFn[obj][eType][fn] = null;}else{obj.removeEventListener(type,fn,false);}    }    else if(obj.attachEvent)    {        obj.detachEvent("on" + type,fn);    }};(function(){/* 这里是演示demo 绑定解除事件 */var outer = $id("outer"),inner = $id("inner");events.addEvent(outer,"mouseenter",add);events.addEvent(outer,"mouseleave",add);events.addEvent(outer,"click",remove);function add(){var e = arguments[0] || window.event;var target = e.srcElement || e.target;inner.innerHTML = target.id + ' ' + e.type;}function remove(){events.removeEvent(outer,"mouseenter",add);events.removeEvent(outer,"mouseleave",add)inner.innerHTML = "click";}})()</script> </textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_7cbdae66-246c-48ad-b5a0-bbdcd49e5607');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_7cbdae66-246c-48ad-b5a0-bbdcd49e5607');" /></p><br>为了解除绑定，我们设计了一个events._mouseFn来保存绑定的方法，在解除操作时读取对应的方法进行解绑。因为事件可以绑定多个方法，我们需要保存对应的方法，以便之后对应解除。<br>当然如果这里如果按面向对象的思路实现，就可以各自保存，而不需要保持在同一个events._mouseFn对象下。但每绑定一个事件，都需实例化一个对象，显得很多余，所以不采用面向对象的模式。</p><p>接下来是文章的第二部分，我们来实现下jquery中提供的delegate方法。<br>（delegate是live方法的扩展版。delegate是基于live的，live是基于bind的。在jquery1.7中又被封装进了on方法。1.7中的on方法是一个很辽阔的方法。其实封装的越厉害，效率就越差了，这也是为什么我们选择自己做简单封装的原因，而不是使用jquery已封装好的）。<br>这个方法可以将想要绑定在子级元素上的事件方法，委托绑定在其父级上，用事件传播机制来触发执行。<br>这么做的好处有：<br>1：如果子级有n个并列元素需要绑定，绑子级需要绑n次，而将其绑定在父级上则只需绑定一次，这是很高效的。<br>2：如果子级元素有动态增加的话，新增元素是没有绑定过任何事件方法的。而如果之前选择的是绑定其父级，就不会有这个问题。<br> <p><textarea class="runcode_text" id="runcode_7f717bb9-3d2f-4655-b990-ea6921cbbe17"><!DOCTYPE html><html><head><meta charset="utf-8" /><title>delegate委托绑定事件方法的实现</title><style>.outer{padding:50px;background:#aaa;zoom:1;}.inner{display:block;height:50px;margin:5px;background:#eee;border:1px solid #ccc;}</style></head><body><div id="outer" class="outer"><div id="message">点击下面框体</div><span class="inner">1:</span><span class="inner">2:</span><span class="inner">3:</span><span class="inner">4:</span><span class="inner">5:</span><div id="unbind">点击解除绑定</div></div></body><script>//一些通用方法var $id=function(o){return document.getElementById(o) || o;}var isDOMs = function(target){return target.length >= 0 && target !== window && !target.tagName;  //!target.tagName排除FORM,SELECT等元素};var hasClass = function(target,className){if(!target || !className) return false;if(target[0]) target = target[0];var pattern = new RegExp("(^|\\s)"+className+"(\\s|$)");return pattern.test(target.className);}//正式开始window.events = {}events._deleFn = {}; //保存delegate所绑定的方法events._mouseFn ={}; //保存“onmouseenter”和“onmouseleave”所绑定的方法events._ieFunc = {}; //由于保存在ie下绑定的方法events._mouseHandle = function(fn){/* 实现mouseenter/leave 的转换方法，符合条件时才会执行 */var func = function(event){var target = event.target;var parent = event.relatedTarget; //在onmouseover/out操作中，相关的另一个节点while( parent && parent != this ){try{ parent = parent.parentNode; }catch(e){break;}}/* 只有当相关节点的父级不会是绑定的节点时（即二者不是父子的包含关系），才调用fn，否则不做处理 */( parent != this ) && (fn.call(target,event));};return func;}events._delegateHandle = function(obj,selector,fn){/* 实现delegate 的转换方法，符合条件时才会执行 */var func = function(event){var event = event || window.event;var target = event.srcElement || event.target;var parent = target;function contain(item,elmName){if(elmName.split('#')[1]){ //by idif(item.id && item.id === elmName.split('#')[1]) return true;}if(elmName.split('.')[1]){ //by classif(hasClass(item, elmName.split('.')[1])) return true;}if(item.tagName == elmName.toUpperCase())  return true; //by tagnamereturn false;}while(parent){/* 如果触发的元素，属于(selector)元素的子级。 */if(obj == parent) return false; //触发元素是自己if(contain(parent,selector)){fn.call(obj,event);return;}parent = parent.parentNode;}};return func;};events.addEvent = function(target,type,fn){if (!target) return false;var add = function(obj){if(obj.addEventListener){obj.addEventListener(type,fn,false);}else{// for ieif(!events._ieFunc[obj]) events._ieFunc[obj] = {};if(!events._ieFunc[obj][type]) events._ieFunc[obj][type] = {};events._ieFunc[obj][type][fn] = function(){fn.apply(obj,arguments);};obj.attachEvent("on" + type,events._ieFunc[obj][type][fn]);}}if(isDOMs(target)) {for(var i=0, l = target.length; i < l; i++){add(target[i])}}else{add(target);}};events.removeEvent = function(target,type,fn) {if (!target) return false;    var remove = function(obj){    if(obj.addEventListener){if(obj.onmouseenter !== undefined){obj.removeEventListener(type,fn,false);return ;}obj.removeEventListener(type,fn,false);}else{//for ieif(!events._ieFunc[obj] ||!events._ieFunc[obj][type] || !events._ieFunc[obj][type][fn]) return;obj.detachEvent("on" + type, events._ieFunc[obj][type][fn],false);events._ieFunc[obj][type][fn]={};}    }    if(isDOMs(target)) {for(var i=0, l = target.length; i < l; i++){remove(target[i])}}else{remove(target);}};events.delegate = function(obj,selector,type,fn){if (!obj || !selector) return false;var fnNew = events._delegateHandle(obj,selector,fn);events.addEvent(obj,type,fnNew);/* 将绑定的方法存入events._deleFn，以便之后解绑操作 */if(!events._deleFn[selector]) events._deleFn[selector] = {};if(!events._deleFn[selector][type]) events._deleFn[selector][type] = {};events._deleFn[selector][type][fn] = fnNew;};events.undelegate = function(obj,selector,type,fn){if (!obj || !selector || !events._deleFn[selector]) return false;var fnNew = events._deleFn[selector][type][fn];if(!fnNew) return;events.removeEvent(obj,type,fnNew);events._deleFn[selector][type][fn] = null;};(function(){/* 这里是演示demo*/var outer = $id("outer"),msg = $id("message");var add = function(){var e = arguments[0] || window.event;var target = e.srcElement || e.target;msg.innerHTML =  target.innerHTML + ' ' + e.type;}function color(){msg.style.color = "#c00"}function remove(){events.undelegate(outer,".inner","click",color);events.undelegate(outer,"#unbind","click",remove);msg.style.color = "#000"msg.innerHTML = "已解除绑定color方法.add方法仍在";}events.delegate(outer,".inner","click",add);events.delegate(outer,".inner","click",color);events.delegate(outer,"#unbind","click",remove);})()</script> </textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_7f717bb9-3d2f-4655-b990-ea6921cbbe17');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_7f717bb9-3d2f-4655-b990-ea6921cbbe17');" /></p><br>这里的实现思路是这样的：如果触发事件的元素，是你想要绑定的元素的子级（当然他肯定已是委托实际绑定元素的子级），就执行绑定的事件方法，否则方法就不执行，看上去就像方法没绑定过一样。<br>同实现onmouseenter一样，我们也设计了一个events._deleFn来用于后面的解绑方法undelegate的实现。<br>另外针对ie，我们还解决了两个问题：</p><ol><li>绑定方法内的this指向问题。我们用.apply执行绑定方法来解决。</li><li>使用apply调用绑定方法，就必须考虑如何解绑方法。原理和_mouseFn还有_deleFn一样。</li></ol><p>在使用delegate时，我们同样遇到了mouseover&#x2F;out的问题。<br>我们的解决方案是：不罗嗦，直接将mouseover&#x2F;out处理成mouseenter&#x2F;leave<br> <p><textarea class="runcode_text" id="runcode_db30e912-b757-40a9-aa0b-58a8c4e52b2b"><!DOCTYPE html><html><head><meta charset="utf-8" /><title>delegate委托绑定事件方法的实现</title><style>.outer{padding:50px;background:#aaa;zoom:1;}.inner{display:block;height:50px;background:#eee;border:1px solid #ccc;}</style></head><body><div id="outer" class="outer"><div id="message">划过下面框体</div><span class="inner">1:</span><span class="inner">2:</span><span class="inner">3:</span><span class="inner">4:</span><span class="inner">5:</span><div id="unbind">点击解除绑定</div></div></body><script>var $id=function(o){return document.getElementById(o) || o;}var isDOMs = function(target){return target.length >= 0 && target !== window && !target.tagName;  //!target.tagName排除FORM,SELECT等元素};window.events = {}events._deleFn = {}; //保存delegate所绑定的方法events._mouseFn ={}; //保存“onmouseenter”和“onmouseleave”所绑定的方法events._ieFunc = {}; //由于保存在ie下绑定的方法events._mouseHandle = function(fn){/* 实现mouseenter/leave 的转换方法，符合条件时才会执行 */var func = function(event){var target = event.target;var parent = event.relatedTarget; //在onmouseover/out操作中，相关的另一个节点while( parent && parent != this ){try{ parent = parent.parentNode; }catch(e){break;}}/* 只有当相关节点的父级不会是绑定的节点时（即二者不是父子的包含关系），才调用fn，否则不做处理 */( parent != this ) && (fn.call(target,event));};return func;}events._delegateHandle = function(obj,selector,fn){/* 实现delegate 的转换方法，符合条件时才会执行 */var func = function(event){var event = event || window.event;var target = event.srcElement || event.target;var parent = target;function contain(item,elmName){if(elmName.split('#')[1]){ //by idif(item.id && item.id === elmName.split('#')[1]) return true;}if(elmName.split('.')[1]){ //by classif(hasClass(item, elmName.split('.')[1])) return true;}if(item.tagName == elmName.toUpperCase())  return true; //by tagnamereturn false;}while(parent){/* 如果触发的元素，属于(selector)元素的子级。 */if(obj == parent) return false; //触发元素是自己if(contain(parent,selector)){if(event.type == 'mouseover' || event.type == 'mouseout'){/** 将mouseover/out直接处理成mouseenter/leave: 事件相关元素不属于绑定元素的子级，才绑定方法*///事件相关元素。ie下使用toElement和fromElement，其他用relatedTarget。var related = event.relatedTarget || ((event.type == 'mouseout') ? event.toElement : event.fromElement);if(contain(target,selector) || contain(related,selector)) {/* 如果，触发元素或相关元素属于绑定元素(selector)。执行方法 */fn.call(obj,event);return;}while( related && !contain(related,selector)){  related = related.parentNode;}/* 事件相关元素，不属于绑定元素(selector)的子级，执行方法  */!contain(related,selector) && (fn.call(obj,event));}else{fn.call(obj,event);}return;}parent = parent.parentNode;}};return func;};events.addEvent = function(target,type,fn){if (!target) return false;var add = function(obj){if(obj.addEventListener){if(obj.onmouseenter !== undefined){//for opera11，firefox10。他们也支持“onmouseenter”和“onmouseleave”，可以直接绑定obj.addEventListener(type,fn,false);return ;}if(type=="mouseenter" || type=="mouseleave" ){var eType = (type=="mouseenter") ? "mouseover" : "mouseout";var fnNew = events._mouseHandle(fn);obj.addEventListener(eType,fnNew,false); /* 将方法存入events._mouseFn，以便以后remove */if(!events._mouseFn[obj]) events._mouseFn[obj] = {};if(!events._mouseFn[obj][eType]) events._mouseFn[obj][eType] = {};events._mouseFn[obj][eType][fn] = fnNew;}else{obj.addEventListener(type,fn,false);}}else{// for ieif(!events._ieFunc[obj]) events._ieFunc[obj] = {};if(!events._ieFunc[obj][type]) events._ieFunc[obj][type] = {};events._ieFunc[obj][type][fn] = function(){fn.apply(obj,arguments);};obj.attachEvent("on" + type,events._ieFunc[obj][type][fn]);}}if(isDOMs(target)) {for(var i=0, l = target.length; i < l; i++){add(target[i])}}else{add(target);}};events.removeEvent = function(target,type,fn) {if (!target) return false;    var remove = function(obj){    if(obj.addEventListener){if(obj.onmouseenter !== undefined){obj.removeEventListener(type,fn,false);return ;}if(type=="mouseenter" || type=="mouseleave" ){var eType = (type=="mouseenter") ? "mouseover" : "mouseout";if(!events._mouseFn[obj][eType][fn]) return;obj.removeEventListener(eType,events._mouseFn[obj][eType][fn],false);events._mouseFn[obj][eType][fn]={};}else{obj.removeEventListener(type,fn,false);}}else{//for ieif(!events._ieFunc[obj] ||!events._ieFunc[obj][type] || !events._ieFunc[obj][type][fn]) return;obj.detachEvent("on" + type, events._ieFunc[obj][type][fn],false);events._ieFunc[obj][type][fn]={};}    }    if(isDOMs(target)) {for(var i=0, l = target.length; i < l; i++){remove(target[i])}}else{remove(target);}};events.delegate = function(obj,selector,type,fn){if (!obj || !selector) return false;var fnNew = events._delegateHandle(obj,selector,fn);events.addEvent(obj,type,fnNew);/* 将绑定的方法存入events._deleFn，以便之后解绑操作 */if(!events._deleFn[selector]) events._deleFn[selector] = {};if(!events._deleFn[selector][type]) events._deleFn[selector][type] = {};events._deleFn[selector][type][fn] = fnNew;};events.undelegate = function(obj,selector,type,fn){if (!obj || !selector || !events._deleFn[selector]) return false;var fnNew = events._deleFn[selector][type][fn];if(!fnNew) return;events.removeEvent(obj,type,fnNew);events._deleFn[selector][type][fn] = null;};(function(){/* 这里是演示demo*/var outer = $id("outer"),msg = $id("message");events.delegate(outer,'span',"mouseover",add);events.delegate(outer,'span',"mouseout",add);events.delegate(outer,'#unbind',"click",remove);function add(){var e = arguments[0] || window.event;var target = e.srcElement || e.target;msg.innerHTML =  target.innerHTML + ' ' + e.type;}function remove(){events.undelegate(outer,'span',"mouseover",add);events.undelegate(outer,'span',"mouseout",add);events.undelegate(outer,'#unbind',"click",remove);}})()</script> </textarea><input type="button" value="Run" class="runcode_button" onclick="runcode.open('runcode_db30e912-b757-40a9-aa0b-58a8c4e52b2b');" />&nbsp;<input type="button" value="Copy" class="runcode_button" onclick="runcode.copy('runcode_db30e912-b757-40a9-aa0b-58a8c4e52b2b');" /></p><br>最后，整理一下，封装一个支持mouseenter 和 mouseleave事件，delegate方法 及其他们的解除绑定的方法的 功能函数库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">window.events = &#123;&#125;</span><br><span class="line">events._deleFn = &#123;&#125;; //保存delegate所绑定的方法   </span><br><span class="line">events._mouseFn =&#123;&#125;; //保存“onmouseenter”和“onmouseleave”所绑定的方法</span><br><span class="line">events._ieFunc = &#123;&#125;; //由于保存在ie下绑定的方法</span><br><span class="line"> </span><br><span class="line">events._mouseHandle = function(fn)&#123;</span><br><span class="line">    /* 实现mouseenter/leave 的转换方法，符合条件时才会执行 */</span><br><span class="line">    var func = function(event)&#123;</span><br><span class="line">        var target = event.target;</span><br><span class="line">        var parent = event.relatedTarget; //在onmouseover/out操作中，相关的另一个节点</span><br><span class="line">        while( parent &amp;&amp; parent != this )&#123; </span><br><span class="line">            try&#123; parent = parent.parentNode; &#125;</span><br><span class="line">            catch(e)&#123;break;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 只有当相关节点的父级不会是绑定的节点时（即二者不是父子的包含关系），才调用fn，否则不做处理 */</span><br><span class="line">        ( parent != this ) &amp;&amp; (fn.call(target,event));</span><br><span class="line">    &#125;;</span><br><span class="line">    return func;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">events._delegateHandle = function(obj,selector,fn)&#123;</span><br><span class="line">    /* 实现delegate 的转换方法，符合条件时才会执行 */</span><br><span class="line">    var func = function(event)&#123;</span><br><span class="line">        var event = event || window.event;</span><br><span class="line">        var target = event.srcElement || event.target;</span><br><span class="line">        var parent = target;</span><br><span class="line">        function contain(item,elmName)&#123;</span><br><span class="line">            if(elmName.split(&#x27;#&#x27;)[1])&#123; //by id</span><br><span class="line">                if(item.id &amp;&amp; item.id === elmName.split(&#x27;#&#x27;)[1]) return true;</span><br><span class="line">            &#125; </span><br><span class="line">            if(elmName.split(&#x27;.&#x27;)[1])&#123; //by class</span><br><span class="line">                if(hasClass(item, elmName.split(&#x27;.&#x27;)[1])) return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if(item.tagName == elmName.toUpperCase())  return true; //by tagname</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        while(parent)&#123;</span><br><span class="line">            /* 如果触发的元素，属于(selector)元素的子级。 */</span><br><span class="line">            if(obj == parent) return false; //触发元素是自己</span><br><span class="line">            if(contain(parent,selector))&#123;</span><br><span class="line">                if(event.type == &#x27;mouseover&#x27; || event.type == &#x27;mouseout&#x27;)&#123;</span><br><span class="line">                    /*</span><br><span class="line">                    * 将mouseover/out直接处理成mouseenter/leave: 事件相关元素不属于绑定元素的子级，才绑定方法</span><br><span class="line">                    */</span><br><span class="line">                    //事件相关元素。ie下使用toElement和fromElement，其他用relatedTarget。</span><br><span class="line">                    var related = event.relatedTarget || ((event.type == &#x27;mouseout&#x27;) ? event.toElement : event.fromElement);</span><br><span class="line">                    if(contain(target,selector) || contain(related,selector)) &#123;</span><br><span class="line">                        /* 如果，触发元素或相关元素属于绑定元素(selector)。执行方法 */</span><br><span class="line">                        fn.call(obj,event);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    while( related &amp;&amp; !contain(related,selector))&#123; </span><br><span class="line">                          related = related.parentNode;</span><br><span class="line">                    &#125;</span><br><span class="line">                    /* 事件相关元素，不属于绑定元素(selector)的子级，执行方法  */</span><br><span class="line">                    !contain(related,selector) &amp;&amp; (fn.call(obj,event));</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    fn.call(obj,event);</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            parent = parent.parentNode;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return func;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">events.addEvent = function(target,type,fn)&#123;</span><br><span class="line">    if (!target) return false;</span><br><span class="line">    var add = function(obj)&#123;</span><br><span class="line">        if(obj.addEventListener)&#123;   </span><br><span class="line">            if(obj.onmouseenter !== undefined)&#123;</span><br><span class="line">                //for opera11，firefox10。他们也支持“onmouseenter”和“onmouseleave”，可以直接绑定</span><br><span class="line">                obj.addEventListener(type,fn,false); </span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            if(type==&quot;mouseenter&quot; || type==&quot;mouseleave&quot; )&#123; </span><br><span class="line">                var eType = (type==&quot;mouseenter&quot;) ? &quot;mouseover&quot; : &quot;mouseout&quot;;</span><br><span class="line">                var fnNew = events._mouseHandle(fn);</span><br><span class="line">                obj.addEventListener(eType,fnNew,false);</span><br><span class="line">                 /* 将方法存入events._mouseFn，以便以后remove */</span><br><span class="line">                if(!events._mouseFn[obj]) events._mouseFn[obj] = &#123;&#125;;</span><br><span class="line">                if(!events._mouseFn[obj][eType]) events._mouseFn[obj][eType] = &#123;&#125;;</span><br><span class="line">                    events._mouseFn[obj][eType][fn] = fnNew;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                obj.addEventListener(type,fn,false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // for ie</span><br><span class="line">            if(!events._ieFunc[obj]) events._ieFunc[obj] = &#123;&#125;;</span><br><span class="line">            if(!events._ieFunc[obj][type]) events._ieFunc[obj][type] = &#123;&#125;;</span><br><span class="line">            events._ieFunc[obj][type][fn] = function()&#123;</span><br><span class="line">                fn.apply(obj,arguments);</span><br><span class="line">            &#125;;</span><br><span class="line">            obj.attachEvent(&quot;on&quot; + type,events._ieFunc[obj][type][fn]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(isDOMs(target)) &#123;</span><br><span class="line">        for(var i=0, l = target.length; i &lt; l; i++)&#123;</span><br><span class="line">            add(target[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        add(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">events.removeEvent = function(target,type,fn) &#123;</span><br><span class="line">    if (!target) return false;</span><br><span class="line">    var remove = function(obj)&#123;</span><br><span class="line">        if(obj.addEventListener)&#123;   </span><br><span class="line">            if(obj.onmouseenter !== undefined)&#123;</span><br><span class="line">                obj.removeEventListener(type,fn,false); </span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            if(type==&quot;mouseenter&quot; || type==&quot;mouseleave&quot; )&#123; </span><br><span class="line">                var eType = (type==&quot;mouseenter&quot;) ? &quot;mouseover&quot; : &quot;mouseout&quot;;</span><br><span class="line">                if(!events._mouseFn[obj][eType][fn]) return;</span><br><span class="line">                obj.removeEventListener(eType,events._mouseFn[obj][eType][fn],false);</span><br><span class="line">                events._mouseFn[obj][eType][fn]=&#123;&#125;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                obj.removeEventListener(type,fn,false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //for ie</span><br><span class="line">            if(!events._ieFunc[obj] ||!events._ieFunc[obj][type] || !events._ieFunc[obj][type][fn]) return;</span><br><span class="line">            obj.detachEvent(&quot;on&quot; + type, events._ieFunc[obj][type][fn],false);</span><br><span class="line">            events._ieFunc[obj][type][fn]=&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(isDOMs(target)) &#123;</span><br><span class="line">        for(var i=0, l = target.length; i &lt; l; i++)&#123;</span><br><span class="line">            remove(target[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        remove(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">events.delegate = function(obj,selector,type,fn)&#123;</span><br><span class="line">    if (!obj || !selector) return false;</span><br><span class="line">    var fnNew = events._delegateHandle(obj,selector,fn);</span><br><span class="line">    events.addEvent(obj,type,fnNew);</span><br><span class="line">    /* 将绑定的方法存入events._deleFn，以便之后解绑操作 */</span><br><span class="line">    if(!events._deleFn[selector]) events._deleFn[selector] = &#123;&#125;;</span><br><span class="line">    if(!events._deleFn[selector][type]) events._deleFn[selector][type] = &#123;&#125;;</span><br><span class="line">    events._deleFn[selector][type][fn] = fnNew;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">events.undelegate = function(obj,selector,type,fn)&#123;</span><br><span class="line">    if (!obj || !selector || !events._deleFn[selector]) return false;</span><br><span class="line">    var fnNew = events._deleFn[selector][type][fn];</span><br><span class="line">    if(!fnNew) return;</span><br><span class="line">    events.removeEvent(obj,type,fnNew);</span><br><span class="line">    events._deleFn[selector][type][fn] = null;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;众所周知，事件onmouseover和onmouseout有一个极其不好的问题，就是在绑定元素内部的子元素上滑动会反复触发事件，及执行绑定的方法。&lt;/p&gt;
&lt;p&gt;而ie在很早的时候有提供了另一对事件：mouseenter和mouseleaver。顾名思义，就是只有当mous</summary>
      
    
    
    
    <category term="developer" scheme="https://www.cssass.com/categories/developer/"/>
    
    
    <category term="DOM" scheme="https://www.cssass.com/tags/DOM/"/>
    
  </entry>
  
</feed>
